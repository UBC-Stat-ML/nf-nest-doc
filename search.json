[
  {
    "objectID": "10_misc.html",
    "href": "10_misc.html",
    "title": "Misc",
    "section": "",
    "text": "To declare a command line argument, say n_rounds to your nextflow script, with default argument 5, use:\nparams.n_rounds = 5\nHere is an example:\n\ninclude { crossProduct; filed; deliverables } from '../cross.nf'\ninclude { instantiate; precompile; activate } from '../pkg.nf'\ninclude { combine_csvs; } from '../combine.nf'\n\ndef julia_env = file(moduleDir/'julia_env')\ndef plot_script = file(moduleDir/'plot.jl')\n\nparams.n_rounds = 5\n\ndef variables = [\n    seed: 1..10,\n    n_chains: [10, 20], \n]\n\nworkflow {\n    compiled_env = instantiate(julia_env) | precompile\n    configs = crossProduct(variables)\n    combined = run_julia(compiled_env, configs) | combine_csvs\n    plot(compiled_env, plot_script, combined)\n}\n\nprocess run_julia {\n    input:\n        path julia_env \n        val config \n    output:\n        path \"${filed(config)}\"\n    \"\"\"\n    ${activate(julia_env)}\n\n    # run your code\n    using Pigeons \n    using CSV \n    pt = pigeons(\n            target = toy_mvn_target(1000), \n            n_chains = ${config.n_chains}, \n            seed = ${config.seed},\n            n_rounds = ${params.n_rounds})\n\n    mkdir(\"${filed(config)}\")\n    CSV.write(\"${filed(config)}/summary.csv\", pt.shared.reports.summary)\n    CSV.write(\"${filed(config)}/swap_prs.csv\", pt.shared.reports.swap_prs)\n    \"\"\"\n}\n\nprocess plot {\n    input:\n        path julia_env \n        path plot_script\n        path combined_csvs_folder \n    output:\n        path '*.png'\n        path combined_csvs_folder\n    publishDir \"${deliverables(workflow, params)}\", mode: 'copy', overwrite: true\n    \"\"\"\n    ${activate(julia_env)}\n\n    include(\"$plot_script\")\n    create_plots(\"$combined_csvs_folder\")\n    \"\"\"\n}\n\nTo run it, notice that the arguments specified by params.my_arg should be specified using --my_arg value (in contrast, nextflow’s argument use a single dash, as in -profile cluster):\n\ncd experiment_repo\n./nextflow run nf-nest/examples/params.nf -profile cluster --n_rounds 6\n\nN E X T F L O W  ~  version 24.10.0\nLaunching `nf-nest/examples/params.nf` [extravagant_swirles] DSL2 - revision: 093b673fc8\n[8c/a117a8] Cached process &gt; instantiate_process\n[5f/997727] Cached process &gt; combine_workflow:instantiate_process\n[72/cc3bb2] Cached process &gt; precompile\n[b9/57c5b2] Cached process &gt; combine_workflow:precompile\n[72/2cc9e6] Submitted process &gt; run_julia (12)\n[cb/0f4ef3] Submitted process &gt; run_julia (9)\n[7b/b152ab] Submitted process &gt; run_julia (3)\n[e1/afa275] Submitted process &gt; run_julia (8)\n[0f/43c83a] Submitted process &gt; run_julia (15)\n[1e/01aeed] Submitted process &gt; run_julia (14)\n[a0/e7e0ae] Submitted process &gt; run_julia (4)\n[7d/d461f8] Submitted process &gt; run_julia (2)\n[88/d0a075] Submitted process &gt; run_julia (1)\n[a6/5caec5] Submitted process &gt; run_julia (10)\n[20/581486] Submitted process &gt; run_julia (13)\n[86/f2ad4d] Submitted process &gt; run_julia (11)\n[42/6b0ba5] Submitted process &gt; run_julia (5)\n[88/275b85] Submitted process &gt; run_julia (6)\n[d6/1cfa52] Submitted process &gt; run_julia (16)\n[1e/635557] Submitted process &gt; run_julia (7)\n[e0/12866b] Submitted process &gt; run_julia (17)\n[0e/b48681] Submitted process &gt; run_julia (19)\n[09/a9a9e5] Submitted process &gt; run_julia (20)\n[dd/afd459] Submitted process &gt; run_julia (18)\n[82/3f2da5] Submitted process &gt; combine_workflow:combine_process\n[bd/575d2c] Submitted process &gt; plot\n\n\nNotice that the function deliverables(workflow, params) takes it into account so that the deliverables directory is organized correctly:\n\ntree experiment_repo/deliverables\n\nexperiment_repo/deliverables\n├── scriptName=full.nf\n│   ├── output\n│   │   ├── summary.csv\n│   │   └── swap_prs.csv\n│   ├── plot.png\n│   └── runName.txt\n└── scriptName=params.nf___n_rounds=6\n    ├── output\n    │   ├── summary.csv\n    │   └── swap_prs.csv\n    ├── plot.png\n    └── runName.txt\n\n4 directories, 8 files",
    "crumbs": [
      "Misc"
    ]
  },
  {
    "objectID": "10_misc.html#process-parameters",
    "href": "10_misc.html#process-parameters",
    "title": "Misc",
    "section": "",
    "text": "To declare a command line argument, say n_rounds to your nextflow script, with default argument 5, use:\nparams.n_rounds = 5\nHere is an example:\n\ninclude { crossProduct; filed; deliverables } from '../cross.nf'\ninclude { instantiate; precompile; activate } from '../pkg.nf'\ninclude { combine_csvs; } from '../combine.nf'\n\ndef julia_env = file(moduleDir/'julia_env')\ndef plot_script = file(moduleDir/'plot.jl')\n\nparams.n_rounds = 5\n\ndef variables = [\n    seed: 1..10,\n    n_chains: [10, 20], \n]\n\nworkflow {\n    compiled_env = instantiate(julia_env) | precompile\n    configs = crossProduct(variables)\n    combined = run_julia(compiled_env, configs) | combine_csvs\n    plot(compiled_env, plot_script, combined)\n}\n\nprocess run_julia {\n    input:\n        path julia_env \n        val config \n    output:\n        path \"${filed(config)}\"\n    \"\"\"\n    ${activate(julia_env)}\n\n    # run your code\n    using Pigeons \n    using CSV \n    pt = pigeons(\n            target = toy_mvn_target(1000), \n            n_chains = ${config.n_chains}, \n            seed = ${config.seed},\n            n_rounds = ${params.n_rounds})\n\n    mkdir(\"${filed(config)}\")\n    CSV.write(\"${filed(config)}/summary.csv\", pt.shared.reports.summary)\n    CSV.write(\"${filed(config)}/swap_prs.csv\", pt.shared.reports.swap_prs)\n    \"\"\"\n}\n\nprocess plot {\n    input:\n        path julia_env \n        path plot_script\n        path combined_csvs_folder \n    output:\n        path '*.png'\n        path combined_csvs_folder\n    publishDir \"${deliverables(workflow, params)}\", mode: 'copy', overwrite: true\n    \"\"\"\n    ${activate(julia_env)}\n\n    include(\"$plot_script\")\n    create_plots(\"$combined_csvs_folder\")\n    \"\"\"\n}\n\nTo run it, notice that the arguments specified by params.my_arg should be specified using --my_arg value (in contrast, nextflow’s argument use a single dash, as in -profile cluster):\n\ncd experiment_repo\n./nextflow run nf-nest/examples/params.nf -profile cluster --n_rounds 6\n\nN E X T F L O W  ~  version 24.10.0\nLaunching `nf-nest/examples/params.nf` [extravagant_swirles] DSL2 - revision: 093b673fc8\n[8c/a117a8] Cached process &gt; instantiate_process\n[5f/997727] Cached process &gt; combine_workflow:instantiate_process\n[72/cc3bb2] Cached process &gt; precompile\n[b9/57c5b2] Cached process &gt; combine_workflow:precompile\n[72/2cc9e6] Submitted process &gt; run_julia (12)\n[cb/0f4ef3] Submitted process &gt; run_julia (9)\n[7b/b152ab] Submitted process &gt; run_julia (3)\n[e1/afa275] Submitted process &gt; run_julia (8)\n[0f/43c83a] Submitted process &gt; run_julia (15)\n[1e/01aeed] Submitted process &gt; run_julia (14)\n[a0/e7e0ae] Submitted process &gt; run_julia (4)\n[7d/d461f8] Submitted process &gt; run_julia (2)\n[88/d0a075] Submitted process &gt; run_julia (1)\n[a6/5caec5] Submitted process &gt; run_julia (10)\n[20/581486] Submitted process &gt; run_julia (13)\n[86/f2ad4d] Submitted process &gt; run_julia (11)\n[42/6b0ba5] Submitted process &gt; run_julia (5)\n[88/275b85] Submitted process &gt; run_julia (6)\n[d6/1cfa52] Submitted process &gt; run_julia (16)\n[1e/635557] Submitted process &gt; run_julia (7)\n[e0/12866b] Submitted process &gt; run_julia (17)\n[0e/b48681] Submitted process &gt; run_julia (19)\n[09/a9a9e5] Submitted process &gt; run_julia (20)\n[dd/afd459] Submitted process &gt; run_julia (18)\n[82/3f2da5] Submitted process &gt; combine_workflow:combine_process\n[bd/575d2c] Submitted process &gt; plot\n\n\nNotice that the function deliverables(workflow, params) takes it into account so that the deliverables directory is organized correctly:\n\ntree experiment_repo/deliverables\n\nexperiment_repo/deliverables\n├── scriptName=full.nf\n│   ├── output\n│   │   ├── summary.csv\n│   │   └── swap_prs.csv\n│   ├── plot.png\n│   └── runName.txt\n└── scriptName=params.nf___n_rounds=6\n    ├── output\n    │   ├── summary.csv\n    │   └── swap_prs.csv\n    ├── plot.png\n    └── runName.txt\n\n4 directories, 8 files",
    "crumbs": [
      "Misc"
    ]
  },
  {
    "objectID": "10_misc.html#dry-runs",
    "href": "10_misc.html#dry-runs",
    "title": "Misc",
    "section": "Dry runs",
    "text": "Dry runs\nA useful application of process parameter is a “dry run switch” for doing a quick version of the pipeline to help quickly debugging.\nHere is an example below. Notice that we pass the dry run option to crossProduct(); instead of emitting all values in the cross product, it will only emit one:\n\ninclude { crossProduct; filed; deliverables } from '../cross.nf'\ninclude { instantiate; precompile; activate } from '../pkg.nf'\n\ndef julia_env = file(moduleDir/'julia_env')\n\nparams.dryRun = false\nparams.n_rounds = params.dryRun ? 1 : 5\n\ndef variables = [\n    seed: 1..10,\n    n_chains: [10, 20], \n]\n\nworkflow {\n    compiled_env = instantiate(julia_env) | precompile\n    configs = crossProduct(variables, params.dryRun)\n    run_julia(compiled_env, configs) \n}\n\nprocess run_julia {\n    input:\n        path julia_env \n        val config \n    \"\"\"\n    ${activate(julia_env)}\n\n    # run your code\n    using Pigeons \n    using CSV \n    pt = pigeons(\n            target = toy_mvn_target(1000), \n            n_chains = ${config.n_chains}, \n            seed = ${config.seed},\n            n_rounds = ${params.n_rounds})\n    \"\"\"\n}\n\nTo run it in dry run model:\n\ncd experiment_repo\n./nextflow run nf-nest/examples/dry_run.nf -profile cluster --dryRun\n\nN E X T F L O W  ~  version 24.10.0\nLaunching `nf-nest/examples/dry_run.nf` [boring_borg] DSL2 - revision: c7304bca14\n[8c/a117a8] Cached process &gt; instantiate_process\n[72/cc3bb2] Cached process &gt; precompile\n[84/b007e6] Submitted process &gt; run_julia (1)",
    "crumbs": [
      "Misc"
    ]
  },
  {
    "objectID": "10_misc.html#what-to-commit",
    "href": "10_misc.html#what-to-commit",
    "title": "Misc",
    "section": "What to commit?",
    "text": "What to commit?\nStandard git guidelines suggest to never commit “derived files”. We recommend to deviate slightly from git conventions and commit a bit more than just strict minimum:\n\nManifest.toml is derived from Project.toml, but commit it, as it contains precise version information needed for reproducibility (in contrast to package developers, who would only commit Project.toml, but numerical experiments is not the same as a package!)\nOnce there are experiments you plan to include in a paper, commit the corresponding sub-folder of deliverables, including the CSV files used to produce that figure. This way the tex repo can just use the experiment repo as a submodule and the authors can compile the paper right away. Having the CSV there also mean that plot esthetics can be quickly tweaked later on (e.g., the night before a talk).",
    "crumbs": [
      "Misc"
    ]
  },
  {
    "objectID": "10_misc.html#updating-code",
    "href": "10_misc.html#updating-code",
    "title": "Misc",
    "section": "Updating code",
    "text": "Updating code\nNumerical experiment are often based on code you are developing along the way. When the code is updated, with a bit of organization, nextflow can figure out which subset of the workflow needs to be re-run. We present two models for doing this: one for lightweight code such as plotting/analysis, and one for more substantial code, e.g. a method you are developing.\n\nLightweight code\nInclude the .jl file in the nextflow repo, feed it to the node as input, and use a Julia include() on it. We have already used that pattern for the plot node in an earlier example.\nIf you have several Julia files, put them in a directory, and use the syntax:\n\ninclude { activate; } from \"../pkg.nf\"\n\ndef julia_files = file(moduleDir/\"julia/*.jl\")\n\nworkflow {\n    run_julia(julia_files)\n}\n\nprocess run_julia {\n    debug true\n    input:\n        file julia_files\n    \"\"\"\n    ${activate()}\n    include(\"a.jl\")\n    include(\"b.jl\")\n    \"\"\"\n}\n\n\ncd experiment_repo\n./nextflow run nf-nest/examples/includes.nf \n\nN E X T F L O W  ~  version 24.10.0\nLaunching `nf-nest/examples/includes.nf` [spontaneous_lorenz] DSL2 - revision: f263a35a46\n[47/6d05cf] Submitted process &gt; run_julia\nhello\nworld\n\n\n\n\n\n\n\n\nWarning\n\n\n\nPassing a directory as input (rather than a collection of files as done above), is not ideal in this context. This is because nextflow does not currently recurse inside the directory to compute the checksum used to determine if the cache can be used. Recall that in unix, the change date of a directory only changes when a file is deleted or added under it, and not when a file under it is edited!\n\n\n\n\nLibrary\nIf the code you include is more complex, and/or might be used outside of the context of one nextflow script, it is better to package it.\nIn Julia, creating a package is very simple and it can be published right away and for free on github: see this tutorial.\nFor example, we wrote a small Julia package, CombineCSV.jl to perform the CSV combination in this earlier section.\nTo add or update, you can use a script of that form:\nENV[\"JULIA_PKG_PRECOMPILE_AUTO\"]=0\nusing Pkg \nPkg.activate(\"julia_env\")\nPkg.add(url = \"https://github.com/UBC-Stat-ML/CombineCSVs\")\nwhere you would replace the URL by the git repo you are using. Note that add will also update to the head of the main branch.\nThis updates the “Manifest.toml” file which in turns signal our “pkg.jl” instantiate utility that it needs to be reran by nextflow:\n\nparams.nPrecompileThreads = 10\n\nparams.julia_env = 'julia_env'\njulia_env = file(params.julia_env)\njulia_env.mkdir()\n\n// Can be used as standalone, but typically used inside a user nf file\nworkflow  {\n    instantiate(julia_env) | precompile\n}\n\ndef instantiate(julia_env) { instantiate_process(julia_env, file(julia_env/\"Manifest.toml\"))}\n\nprocess instantiate_process {\n    executor 'local' // we need internet access\n    scratch false // we want changes in Manifest.toml to be saved\n    input: \n        path julia_env\n        path toml // needed for correct cache behaviour under updates\n    output:\n        path julia_env\n\n    \"\"\"\n    ${activate(julia_env)}\n\n    ENV[\"JULIA_PKG_PRECOMPILE_AUTO\"]=0\n    using Pkg\n    Pkg.instantiate()\n    \"\"\"\n}\n\nprocess precompile {\n    input:\n        path julia_env\n    output:\n        path julia_env\n    cpus params.nPrecompileThreads \n    memory 15.GB\n    \"\"\"\n    ${activate(julia_env, params.nPrecompileThreads)}\n\n    using Pkg \n    Pkg.offline(true) \n    Pkg.precompile()\n    \"\"\"\n}\n\n// Start Julia and with the provided environment and optionally, number of threads (1 by default) \n// Needs to be the very first line of the process script\ndef activate(julia_env, nThreads = 1) {\n    return \"#!/usr/bin/env julia --threads=${nThreads} --project=$julia_env\"\n}\n\ndef activate() {\n    return \"#!/usr/bin/env julia --threads=1\"\n}",
    "crumbs": [
      "Misc"
    ]
  },
  {
    "objectID": "10_misc.html#report",
    "href": "10_misc.html#report",
    "title": "Misc",
    "section": "Report",
    "text": "Report\nFollowing the nextflow documentation, we have set nextflow.config so that report.html, timeline.html and dag.html are automatically created.\nTo preview them in VS Code, add a VS Code Extension allowing html preview, for example Live Server. Then right click on the html file and select Show Preview.",
    "crumbs": [
      "Misc"
    ]
  },
  {
    "objectID": "09_gpu.html",
    "href": "09_gpu.html",
    "title": "GPU programming",
    "section": "",
    "text": "In a context such as Sockeye where it is not possible to access GPU nodes with internet access, precompilation becomes more complicated than the earlier page on non-CUDA precompilation.\nWe provide a workaround, pkg_gpu.nf, which offers the same functionality as pkg.nf but is slower since all precompilation has to occur on the login node.\nFirst, add the package as before:\n\nENV[\"JULIA_PKG_PRECOMPILE_AUTO\"]=0 # Hold off precompile since we are in login node\nusing Pkg \nPkg.activate(\"experiment_repo/julia_env\")\nPkg.add(\"CUDA\")\n\nNext, use the GPU precompilation script:\n\ncd experiment_repo \n./nextflow run nf-nest/pkg_gpu.nf \n\nN E X T F L O W  ~  version 24.10.0\nLaunching `nf-nest/pkg_gpu.nf` [clever_neumann] DSL2 - revision: 713b74ac4a\n[2a/8719cd] Submitted process &gt; instantiate_process\n[18/d35b0f] Submitted process &gt; precompile_gpu",
    "crumbs": [
      "GPU programming"
    ]
  },
  {
    "objectID": "09_gpu.html#installing-cuda.jl",
    "href": "09_gpu.html#installing-cuda.jl",
    "title": "GPU programming",
    "section": "",
    "text": "In a context such as Sockeye where it is not possible to access GPU nodes with internet access, precompilation becomes more complicated than the earlier page on non-CUDA precompilation.\nWe provide a workaround, pkg_gpu.nf, which offers the same functionality as pkg.nf but is slower since all precompilation has to occur on the login node.\nFirst, add the package as before:\n\nENV[\"JULIA_PKG_PRECOMPILE_AUTO\"]=0 # Hold off precompile since we are in login node\nusing Pkg \nPkg.activate(\"experiment_repo/julia_env\")\nPkg.add(\"CUDA\")\n\nNext, use the GPU precompilation script:\n\ncd experiment_repo \n./nextflow run nf-nest/pkg_gpu.nf \n\nN E X T F L O W  ~  version 24.10.0\nLaunching `nf-nest/pkg_gpu.nf` [clever_neumann] DSL2 - revision: 713b74ac4a\n[2a/8719cd] Submitted process &gt; instantiate_process\n[18/d35b0f] Submitted process &gt; precompile_gpu",
    "crumbs": [
      "GPU programming"
    ]
  },
  {
    "objectID": "09_gpu.html#running-nextflow-processes-requiring-gpu",
    "href": "09_gpu.html#running-nextflow-processes-requiring-gpu",
    "title": "GPU programming",
    "section": "Running nextflow processes requiring GPU",
    "text": "Running nextflow processes requiring GPU\nAn example of a workflow using GPUs:\n\ninclude { instantiate; precompile_gpu; } from \"../pkg_gpu.nf\"\ninclude { activate; } from \"../pkg.nf\"\n\ndef julia_env = file('julia_env')\n\nworkflow {\n    instantiate(julia_env) | precompile_gpu | run_julia\n}\n\nprocess run_julia {\n    debug true\n    label 'gpu'\n    input:\n        path julia_env\n    \"\"\"\n    ${activate(julia_env)}\n\n    using CUDA \n\n    println(\"CPU\")\n    x = rand(5000, 5000);\n    @time x * x;\n    @time x * x;\n\n    println(\"GPU\")\n    x = CUDA.rand(5000, 5000);\n    @time x * x;\n    @time x * x;\n\n    CUDA.versioninfo()\n    \"\"\"\n}\n\nWe run it using the same command as usual:\n\ncd experiment_repo\n./nextflow run nf-nest/examples/gpu.nf -profile cluster\n\nN E X T F L O W  ~  version 24.10.0\nLaunching `nf-nest/examples/gpu.nf` [voluminous_coulomb] DSL2 - revision: 9be41cea49\n[e0/640d79] Submitted process &gt; instantiate_process\n[62/a5286f] Submitted process &gt; precompile_gpu\n[51/94d515] Submitted process &gt; run_julia\nCPU\n 13.110772 seconds (4.79 M allocations: 517.701 MiB, 3.77% gc time, 18.17% compilation time)\n 10.580591 seconds (2 allocations: 190.735 MiB, 0.17% gc time)\nGPU\n  1.518137 seconds (1.67 M allocations: 107.375 MiB, 98.30% compilation time)\n  0.000597 seconds (50 allocations: 1.172 KiB)\nCUDA runtime 12.5, artifact installation\nCUDA driver 12.6\nNVIDIA driver 550.90.12\n\nCUDA libraries: \n- CUBLAS: 12.5.3\n- CURAND: 10.3.6\n- CUFFT: 11.2.3\n- CUSOLVER: 11.6.3\n- CUSPARSE: 12.5.1\n- CUPTI: 2024.2.1 (API 23.0.0)\n- NVML: 12.0.0+550.90.12\n\nJulia packages: \n- CUDA: 5.5.2\n- CUDA_Driver_jll: 0.10.3+0\n- CUDA_Runtime_jll: 0.15.3+0\n\nToolchain:\n- Julia: 1.10.2\n- LLVM: 15.0.7\n\nPreferences:\n- CUDA_Runtime_jll.version: 12.5\n\n1 device:\n  0: Tesla V100-SXM2-32GB (sm_70, 31.137 GiB / 32.000 GiB available)",
    "crumbs": [
      "GPU programming"
    ]
  },
  {
    "objectID": "09_gpu.html#gpu-kernel-development",
    "href": "09_gpu.html#gpu-kernel-development",
    "title": "GPU programming",
    "section": "GPU kernel development",
    "text": "GPU kernel development\nOne way to leverage GPUs is to use array programming as demonstrated in the example above. When a problem cannot be cast into an array problem, an alternative is to construct a custom GPU kernel.\nDesigning custom GPU kernels is especially attractive in Julia. This is in big part thanks to\nKernelAbstractions.jl, which allows the same code to be emit both CPU and GPU versions. Since error messages are easier to interpret when doing CPU development, it is useful to be able to test both CPU and GPU targets.\nCompared to Julia CPU development, the main constraint when doing GPU development is that inside the kernel there should not be heap allocations. Seasoned Julia developers are often already often avoiding to allocate in the inner loop due to garbage collection costs.\nFor a concrete example of KernelAbstractions.jl in action, see these kernels used to implement Sequential Annealed Importance Sampling.",
    "crumbs": [
      "GPU programming"
    ]
  },
  {
    "objectID": "06_cross_product.html",
    "href": "06_cross_product.html",
    "title": "Job cross products",
    "section": "",
    "text": "Suppose you are interested in running a piece of code with many different inputs, with each execution performed on a different compute node of a cluster.\nThis page shows a streamlined way to do so.",
    "crumbs": [
      "Job cross products"
    ]
  },
  {
    "objectID": "06_cross_product.html#overview",
    "href": "06_cross_product.html#overview",
    "title": "Job cross products",
    "section": "",
    "text": "Suppose you are interested in running a piece of code with many different inputs, with each execution performed on a different compute node of a cluster.\nThis page shows a streamlined way to do so.",
    "crumbs": [
      "Job cross products"
    ]
  },
  {
    "objectID": "06_cross_product.html#example",
    "href": "06_cross_product.html#example",
    "title": "Job cross products",
    "section": "Example",
    "text": "Example\nAs a toy example, suppose we want to compute all additions of the form a + b where a and b are integers from 1 to 3. In addition, we also want a * b. This means we will need \\(3 \\times 3 \\times 2\\) calculations.\nWe can characterize the inputs a the cross-product denoted \\(\\{1, 2, 3\\} \\times \\{1, 2, 3\\} \\times \\{+, *\\}\\).",
    "crumbs": [
      "Job cross products"
    ]
  },
  {
    "objectID": "06_cross_product.html#nextflow-script",
    "href": "06_cross_product.html#nextflow-script",
    "title": "Job cross products",
    "section": "Nextflow script",
    "text": "Nextflow script\nThe script below will perform the following operations.\n\n// we use utilities in the nf-nest submodule\n// in user scripts, path would be './nf-nest/cross.nf' \ninclude { crossProduct; filed; deliverables } from '../cross.nf'\ninclude { instantiate; precompile; activate } from '../pkg.nf'\n\ndef variables = [\n    first: 1..3,\n    second: 1..3,\n    operation: [\"+\", \"*\"]\n]\n\n// specifies the order of operations\nworkflow {\n    // look at all combinations of variables\n    configs = crossProduct(variables)\n    // run Julia on 18 nodes!\n    run_julia(configs)\n\n    // equivalent syntax:\n    // crossProduct(variables) | run_julia\n}\n\nprocess run_julia {\n    debug true // by default, standard out is not shown, use this to show it\n    \n    // information used when submitting job to queue\n    time 2.min\n    cpus 1 \n    memory 5.GB\n\n    input:\n        val config \n    \"\"\"\n    ${activate()}\n    # ^ this is just a shortcut for:\n    #!/usr/bin/env julia --threads=1\n\n    @show ${config.first} ${config.operation} ${config.second}\n    \"\"\"\n}\n\nFor more information:\n\nRead on the nextflow scripting language\nRead on nextflow’s process block\nconfigs in the above is an example of a nextflow Channel\nMore on nextflow’s workflow block",
    "crumbs": [
      "Job cross products"
    ]
  },
  {
    "objectID": "06_cross_product.html#running-the-script",
    "href": "06_cross_product.html#running-the-script",
    "title": "Job cross products",
    "section": "Running the script",
    "text": "Running the script\nRunning it with the -profile cluster option will:\n\nbuild a cross-product from variables\nfor each one, automatically create submission scripts\nrun these Julia processes and show the standard out.\n\nFrom the command line, running the script is done as follows:\n\ncd experiment_repo\n./nextflow run nf-nest/examples/many_jobs.nf -profile cluster\n\nN E X T F L O W  ~  version 24.10.0\nLaunching `nf-nest/examples/many_jobs.nf` [elegant_fermi] DSL2 - revision: aa082b1978\n[4d/7492f2] Submitted process &gt; run_julia (7)\n[6c/41c384] Submitted process &gt; run_julia (6)\n[dd/7a5a36] Submitted process &gt; run_julia (14)\n[e8/b7de0b] Submitted process &gt; run_julia (9)\n[f0/6df027] Submitted process &gt; run_julia (1)\n[a3/ef9de9] Submitted process &gt; run_julia (4)\n[a3/f36c6f] Submitted process &gt; run_julia (2)\n[eb/83e088] Submitted process &gt; run_julia (16)\n[73/038281] Submitted process &gt; run_julia (3)\n[2c/689c09] Submitted process &gt; run_julia (15)\n[14/7503f2] Submitted process &gt; run_julia (8)\n[d8/14676b] Submitted process &gt; run_julia (10)\n[6e/7edb12] Submitted process &gt; run_julia (5)\n[ae/f4128b] Submitted process &gt; run_julia (13)\n[9c/092e9c] Submitted process &gt; run_julia (11)\n[60/531ea0] Submitted process &gt; run_julia (12)\n[d4/d42221] Submitted process &gt; run_julia (18)\n[0b/f6b1c6] Submitted process &gt; run_julia (17)\n2 + 1 = 3\n1 * 3 = 3\n3 * 1 = 3\n2 + 2 = 4\n1 + 1 = 2\n1 * 2 = 2\n1 * 1 = 1\n3 * 2 = 6\n2 * 2 = 4\n1 + 3 = 4\n3 + 1 = 4\n3 * 3 = 9\n3 + 3 = 6\n1 + 2 = 3\n3 + 2 = 5\n2 * 1 = 2\n2 + 3 = 5\n2 * 3 = 6",
    "crumbs": [
      "Job cross products"
    ]
  },
  {
    "objectID": "06_cross_product.html#filtering",
    "href": "06_cross_product.html#filtering",
    "title": "Job cross products",
    "section": "Filtering",
    "text": "Filtering\nIn some case we want to run only a subset of the cross product. For example, suppose we want only the runs of the form a * a and a + a. This can be done using the filter() function in nextflow:\n\n// we use utilities in the nf-nest submodule\n// in user scripts, path would be './nf-nest/cross.nf' \ninclude { crossProduct; filed; deliverables } from '../cross.nf'\ninclude { instantiate; precompile; activate } from '../pkg.nf'\n\ndef variables = [\n    first: 1..3,\n    second: 1..3,\n    operation: [\"+\", \"*\"]\n]\n\n// specifies the order of operations\nworkflow {\n    configs = crossProduct(variables).filter{ config -&gt; config.first == config.second }\n    run_julia(configs)\n\n    // equivalent pipe syntax:\n    // crossProduct(variables) | filter{ config -&gt; config.first == config.second } | run_julia\n}\n\nprocess run_julia {\n    debug true // by default, standard out is not shown, use this to show it\n    input:\n        val config \n    \"\"\"\n    ${activate()}\n\n    @show ${config.first} ${config.operation} ${config.second}\n    \"\"\"\n}\n\nRunning this\n\ncd experiment_repo\n./nextflow run nf-nest/examples/filter.nf  \n\nN E X T F L O W  ~  version 24.10.0\nLaunching `nf-nest/examples/filter.nf` [tiny_elion] DSL2 - revision: d9de661ecc\n[c0/6ac1a6] Submitted process &gt; run_julia (4)\n[b5/180362] Submitted process &gt; run_julia (1)\n[e9/7403a5] Submitted process &gt; run_julia (3)\n[30/748169] Submitted process &gt; run_julia (6)\n[52/c579d6] Submitted process &gt; run_julia (2)\n[c1/141e36] Submitted process &gt; run_julia (5)\n2 * 2 = 4\n2 + 2 = 4\n1 * 1 = 1\n1 + 1 = 2\n3 * 3 = 9\n3 + 3 = 6",
    "crumbs": [
      "Job cross products"
    ]
  },
  {
    "objectID": "04_launch.html",
    "href": "04_launch.html",
    "title": "Launching an experiment",
    "section": "",
    "text": "We show how to launch an “experiment”, i.e., a nextflow script.\nWe cover two ways to launch an experiment:\n\nLocal: where all processes (nodes in the workflow graph) run in the same machine.\nCluster where each node in the graph can run in different machines in a cluster.\n\nMethod 1 is useful to run experiments on a laptop and for prototyping.\nSurprisingly, thanks to nextflow, method 2 only involves adding the command line option -profile cluster. This is because nextflow takes care of generating submission scripts, transferring files and orchestring everything.",
    "crumbs": [
      "Launch an experiment"
    ]
  },
  {
    "objectID": "04_launch.html#overview",
    "href": "04_launch.html#overview",
    "title": "Launching an experiment",
    "section": "",
    "text": "We show how to launch an “experiment”, i.e., a nextflow script.\nWe cover two ways to launch an experiment:\n\nLocal: where all processes (nodes in the workflow graph) run in the same machine.\nCluster where each node in the graph can run in different machines in a cluster.\n\nMethod 1 is useful to run experiments on a laptop and for prototyping.\nSurprisingly, thanks to nextflow, method 2 only involves adding the command line option -profile cluster. This is because nextflow takes care of generating submission scripts, transferring files and orchestring everything.",
    "crumbs": [
      "Launch an experiment"
    ]
  },
  {
    "objectID": "04_launch.html#example-nextflow-script",
    "href": "04_launch.html#example-nextflow-script",
    "title": "Launching an experiment",
    "section": "Example nextflow script",
    "text": "Example nextflow script\nThe nf-nest repo contains a small example nextflow script, which we will use to demonstrate the two ways to launch an experiment. Here is the script for reference:\n\nworkflow  {\n    hello()\n}\n\nprocess hello {\n    debug true \n    \"\"\"\n    echo Hello world!\n    \"\"\"\n}",
    "crumbs": [
      "Launch an experiment"
    ]
  },
  {
    "objectID": "04_launch.html#local-execution",
    "href": "04_launch.html#local-execution",
    "title": "Launching an experiment",
    "section": "Local execution",
    "text": "Local execution\nUse the following command to run the nextflow script locally:\n\ncd experiment_repo\n./nextflow run nf-nest/examples/hello.nf\n\nN E X T F L O W  ~  version 24.10.0\nWARN: It appears you have never run this project before -- Option `-resume` is ignored\nLaunching `nf-nest/examples/hello.nf` [angry_northcutt] DSL2 - revision: 9d1a692a7e\n[d4/dbd00f] Submitted process &gt; hello\nHello world!",
    "crumbs": [
      "Launch an experiment"
    ]
  },
  {
    "objectID": "04_launch.html#cluster-execution",
    "href": "04_launch.html#cluster-execution",
    "title": "Launching an experiment",
    "section": "Cluster execution",
    "text": "Cluster execution\nTo run on a cluster, add the argument -profile cluster which instructs nextflow to use the configs in section cluster { ... } of the file nextflow.config created in the setup instructions.1\nHere is a minimal example:\n\n./nextflow run nf-nest/examples/hello.nf -profile cluster \n\nN E X T F L O W  ~  version 24.10.0\nLaunching `nf-nest/examples/hello.nf` [wise_goldberg] DSL2 - revision: 9d1a692a7e\n[d4/dbd00f] Cached process &gt; hello\nHello world!",
    "crumbs": [
      "Launch an experiment"
    ]
  },
  {
    "objectID": "04_launch.html#managing-long-executions",
    "href": "04_launch.html#managing-long-executions",
    "title": "Launching an experiment",
    "section": "Managing long executions",
    "text": "Managing long executions\nWhen starting a job, the launching nextflow process needs to stay alive until the end of the last job. However, when the SSH connection is lost (e.g., you close your laptop), the nextflow process and hence child jobs will be killed. To avoid this, use screen or tmux which allows you to preserve a SSH session even if the SSH connection is closed.\n\nBasic instructions to start a long job\n\nTake note of which of the login nodes you are starting the job (e.g. in Sockeye, login01, login02 or login03).\nList existing tmux sessions with tmux ls\nCreate one with tmux or join last one with tmux a\nStart the nextflow.\nTo detach the tmux session ctrl-b followed by d\n\n\n\nLook at the status after being disconnected\n\nSSH in.\nIf you are in the wrong login node, use e.g., ssh login02 (follow 2FA instruction)\nReattach with tmux a\n\nFor more information on tmux, use this cheat sheet.\n\n\nCancelling a nextflow workflow\nPress ctrl-c only once. This will instruct nextflow to clean up children jobs: killing running jobs, as well as cancelling queued jobs.",
    "crumbs": [
      "Launch an experiment"
    ]
  },
  {
    "objectID": "04_launch.html#footnotes",
    "href": "04_launch.html#footnotes",
    "title": "Launching an experiment",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nIn the previous section (“local execution”), where we did not specify a -profile, the default profile named standard is used.↩︎",
    "crumbs": [
      "Launch an experiment"
    ]
  },
  {
    "objectID": "02_setup.html",
    "href": "02_setup.html",
    "title": "Setting up your HPC account",
    "section": "",
    "text": "You will need to go through these setup instructions before using nf-nest. This needs to be done only once per user and per cluster.",
    "crumbs": [
      "Setup your HPC account"
    ]
  },
  {
    "objectID": "02_setup.html#overview",
    "href": "02_setup.html#overview",
    "title": "Setting up your HPC account",
    "section": "",
    "text": "You will need to go through these setup instructions before using nf-nest. This needs to be done only once per user and per cluster.",
    "crumbs": [
      "Setup your HPC account"
    ]
  },
  {
    "objectID": "02_setup.html#prerequisites",
    "href": "02_setup.html#prerequisites",
    "title": "Setting up your HPC account",
    "section": "Prerequisites",
    "text": "Prerequisites\n\nWorking knowledge of unix (files, permissions, processes, environment variables).\nWorking knowledge of git.\n\nThere are countless web resources to learn those things. Tedious but worth the investment.",
    "crumbs": [
      "Setup your HPC account"
    ]
  },
  {
    "objectID": "02_setup.html#optional-password-less-ssh",
    "href": "02_setup.html#optional-password-less-ssh",
    "title": "Setting up your HPC account",
    "section": "Optional: Password-less SSH",
    "text": "Optional: Password-less SSH\nIt is imperative for your sanity to avoid entering your password and do 2FA every time a SSH connection is needed.\nFor example, on Sockeye, the closest you can get to that is with SSH Connection Sharing. This means that you open a first terminal window and perform 2FA in it. As long as that window is open, other SSH connections can be established without password and 2FA. Minimize that first window and do not touch it.",
    "crumbs": [
      "Setup your HPC account"
    ]
  },
  {
    "objectID": "02_setup.html#optional-install-vs-code",
    "href": "02_setup.html#optional-install-vs-code",
    "title": "Setting up your HPC account",
    "section": "Optional: Install VS Code",
    "text": "Optional: Install VS Code\nVS Code makes it easier to develop on a remote server. For example, it simplifies file editing, resuming your session, manages github credential for you, etc.\n\nOn your laptop, install VSCode.\nFollow two steps documented in the VS Code website\n\nInstall the SSH extension\nClick on the Remote SSH icon in the lower left, this will let you Connect to Remote Host.\n\n\nUse New Terminal to open a terminal. Once you have a project (git repo) where you develop ready, use Open Folder... to point VS Code to the root of your project. VS Code is also able to manage your github authentification.",
    "crumbs": [
      "Setup your HPC account"
    ]
  },
  {
    "objectID": "02_setup.html#understanding-start-up-files",
    "href": "02_setup.html#understanding-start-up-files",
    "title": "Setting up your HPC account",
    "section": "Understanding start up files",
    "text": "Understanding start up files\nBash (and its cousins such as zsh) are used in two main ways:\n\nWhen you login via SSH.\nAfter being logged in, bash can be called by another process (e.g. bash, VS Code).\n\nVS Code internally uses 1 once but hides it, and when a new terminal in VS Code is opened, it is done via 2.\nWhen bash is started with 1, the file ~/.bash_profile is called. When bash is started with 2, the file ~/.bashrc is sometimes called.1\nSince we do 2 more frequently, we want it to be fast. It is OK if some operations in 1 are a bit slow because it is less frequently called.\nTypically anything in 2 we want it to happen in 1 as well. So use this:\n# put that in .bash_profile so that anything in .bashrc also gets loaded\nif [ -f ~/.bashrc ]; then\n    . ~/.bashrc\nfi\nRecall that any environment variables with export are passed in to child process. So no need to set them every time in 2, instead you can set them once and for all in 1 (but then you need to login again for this take effect).\nOn the other hand, aything with alias, module, etc, is not propagated.",
    "crumbs": [
      "Setup your HPC account"
    ]
  },
  {
    "objectID": "02_setup.html#git",
    "href": "02_setup.html#git",
    "title": "Setting up your HPC account",
    "section": "Git",
    "text": "Git\nWe assume the command git is available.\nIn some HPC such as UBC Sockeye, this command is not available by default, instead a module has to be loaded:\n\nmodule load git",
    "crumbs": [
      "Setup your HPC account"
    ]
  },
  {
    "objectID": "02_setup.html#allocation-code",
    "href": "02_setup.html#allocation-code",
    "title": "Setting up your HPC account",
    "section": "Allocation code",
    "text": "Allocation code\nIn some HPC such as UBC Sockeye, we need an allocation code to submit to the job queue. Scripts in nf-nest use an ENV variable called ALLOCATION_CODE to find the allocation code.\nTo set the variable in your current session, use:\n\nexport ALLOCATION_CODE=my-alloc-code",
    "crumbs": [
      "Setup your HPC account"
    ]
  },
  {
    "objectID": "02_setup.html#optional-disable-nextflow-fancy-output",
    "href": "02_setup.html#optional-disable-nextflow-fancy-output",
    "title": "Setting up your HPC account",
    "section": "Optional: disable nextflow fancy output",
    "text": "Optional: disable nextflow fancy output\nIt can be useful to avoid nextflow’s fancy progress output, for example they do not work well in notebook or in screen.\nTo disable in the current session, use:\n\nexport NXF_ANSI_LOG=false",
    "crumbs": [
      "Setup your HPC account"
    ]
  },
  {
    "objectID": "02_setup.html#java",
    "href": "02_setup.html#java",
    "title": "Setting up your HPC account",
    "section": "Java",
    "text": "Java\nNextflow needs Java. Follow these instructions taken from the nextflow website:\nFirst, Install SDKMAN\ncurl -s https://get.sdkman.io | bash\nSecond, open a new terminal, and install Java:\nsdk install java 17.0.10-tem\nFinally, confirm that Java in installed correctly:\njava -version",
    "crumbs": [
      "Setup your HPC account"
    ]
  },
  {
    "objectID": "02_setup.html#install-julia",
    "href": "02_setup.html#install-julia",
    "title": "Setting up your HPC account",
    "section": "Install Julia",
    "text": "Install Julia\nAt the time of writing, Julia 1.11 is causing various issues, so install Julia 1.10 using the “Linux and FreeBSD” instructions but using the URL for the Long-term support version 1.10.6.\nYou do not need root privileges, e.g., install in a folder at ~/bin/ and add to your path.",
    "crumbs": [
      "Setup your HPC account"
    ]
  },
  {
    "objectID": "02_setup.html#julia-depot",
    "href": "02_setup.html#julia-depot",
    "title": "Setting up your HPC account",
    "section": "Julia depot",
    "text": "Julia depot\nJulia has a package manager called Pkg. The Julia depot folder is a location where Pkg puts files it downloads and compiles. Each user should have their own. The path to the depot is controlled via the JULIA_DEPOT_PATH environment variable.\nIn a HPC setup, the JULIA_DEPOT_PATH should be accessible read/write by all nodes, and ideally be on fast storage.\nFor example, on Sockeye the first choice if you allocation has it would be to use burst storage, i.e. path of the form\nexport JULIA_DEPOT_PATH=/arc/burst/[allocation_code]/[username_in_alloc]/depot\nA second choice would be to use the scratch space\nexport JULIA_DEPOT_PATH=/scratch/[allocation_code]/[username_in_alloc]/depot",
    "crumbs": [
      "Setup your HPC account"
    ]
  },
  {
    "objectID": "02_setup.html#optional-useful-aliases",
    "href": "02_setup.html#optional-useful-aliases",
    "title": "Setting up your HPC account",
    "section": "Optional: useful aliases",
    "text": "Optional: useful aliases\nBash supports shortcuts called alias for commonly used commands. We show two use cases here.\nA very common patter in Julia is to activate the environment in the current directory and load Revise.jl. To do so, create a Julia script in your home directory called julia-start.jl and put that in it:\nprintln(\"Active project: $(Base.active_project())\")\nprintln(\"Loading Revise...\")\nusing Revise\nThen add the following to .bashrc:\nalias j='julia --banner=no --load /home/[your_alloc]/julia-start.jl --project=@. ' \nYou will need to install Revise.jl in the global environment:\njulia\n]\nactivate\nadd Revise \nSecond, most HPC has some ways to start an interactive allocation. Create an alias to be able to do it quicly. Here is an example for interactive CPU and GPU nodes respectively on Sockeye:\nalias interact='salloc --time=3:00:00 --mem=16G --nodes=1 --ntasks=2 --account=[your_alloc]'\nalias ginteract='salloc --account=[your_alloc-gpu] --partition=interactive_gpu --time=3:00:00 -N 1 -n 2 --mem=16G --gpus=1'",
    "crumbs": [
      "Setup your HPC account"
    ]
  },
  {
    "objectID": "02_setup.html#footnotes",
    "href": "02_setup.html#footnotes",
    "title": "Setting up your HPC account",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nWe emphasize “sometimes” here: for example, when nextflow calls bash, to make things reproducible, it does not automatically pass environment variables. They have to be set explicitly using input environment variables. More generally, any parent process is free to decide which environment variables to propagate to its child. Bash uses export to make this decision automatically when it starts a child. Other languages such as nextflow make different decisions.↩︎",
    "crumbs": [
      "Setup your HPC account"
    ]
  },
  {
    "objectID": "01_intro.html",
    "href": "01_intro.html",
    "title": "Intro",
    "section": "",
    "text": "Large scale numerical experiments are central to much of contemporary scientific and mathematical research. Performing these numerical experiments in a valid, reproducible and scalable fashion is not easy. Even a small typical project may need to run 1000s of executions, and 10k+ is not uncommon. It is crucial to have good tools to coordinate and organize these experiments.",
    "crumbs": [
      "Introduction"
    ]
  },
  {
    "objectID": "01_intro.html#context",
    "href": "01_intro.html#context",
    "title": "Intro",
    "section": "",
    "text": "Large scale numerical experiments are central to much of contemporary scientific and mathematical research. Performing these numerical experiments in a valid, reproducible and scalable fashion is not easy. Even a small typical project may need to run 1000s of executions, and 10k+ is not uncommon. It is crucial to have good tools to coordinate and organize these experiments.",
    "crumbs": [
      "Introduction"
    ]
  },
  {
    "objectID": "01_intro.html#nf-nest",
    "href": "01_intro.html#nf-nest",
    "title": "Intro",
    "section": "nf-nest",
    "text": "nf-nest\nThis webpage documents nf-nest, a collection of small but powerful utilities built on nextflow to help accomplish this. Link to github repository..\nAspects taken into account:\n\nAutomating cross-product of input parameters in experiments.\nAutomating creation of submission scripts and ordering of jobs (taking care of moving across file system, dynamic memory requirements, etc).\nAutomating the gathering of results from many runs.\nCaching already ran jobs.\nRobustness to failure.\nReproducibility via apptainer and docker, supporting both x86 and apple silicon.\nSupport for GPU programming.",
    "crumbs": [
      "Introduction"
    ]
  },
  {
    "objectID": "01_intro.html#technology-stack",
    "href": "01_intro.html#technology-stack",
    "title": "Intro",
    "section": "Technology stack",
    "text": "Technology stack\nnf-nest uses the following open source projects:\n\nNextflow: can be thought of as an “operating system” for coordinating numerical experiments.\nJulia: a programming language to unlock full access to high performance computation on both CPUs and GPUs.\n\nWhile some features of nf-nest are Julia specific, other parts are language agnostic.",
    "crumbs": [
      "Introduction"
    ]
  },
  {
    "objectID": "01_intro.html#background",
    "href": "01_intro.html#background",
    "title": "Intro",
    "section": "Background",
    "text": "Background\n\nScientific workflow\nA scientific workflow is a directed acyclic graph where each node is a process and each edge between node \\(n\\) to \\(n'\\) denote that at least one output of process \\(n\\) is fed as an input to process \\(n'\\).\nHere is an example from a workflow covered later in this tutorial:\n\n\n\n\n\nflowchart TB\n    subgraph \" \"\n    v0[\"julia_env\"]\n    v1[\"toml\"]\n    v4[\"Channel.fromList\"]\n    v7[\"julia_env\"]\n    v8[\"toml\"]\n    v12[\"plot_script\"]\n    end\n    v2([instantiate_process])\n    v3([precompile])\n    v5([run_julia])\n    subgraph combine_workflow\n    v9([instantiate_process])\n    v10([precompile])\n    v11([combine_process])\n    end\n    v13([plot])\n    subgraph \" \"\n    v14[\"combined_csvs_folder\"]\n    v15[\" \"]\n    end\n    v6(( ))\n    v0 --&gt; v2\n    v1 --&gt; v2\n    v2 --&gt; v3\n    v3 --&gt; v5\n    v3 --&gt; v13\n    v4 --&gt; v5\n    v5 --&gt; v6\n    v7 --&gt; v9\n    v8 --&gt; v9\n    v9 --&gt; v10\n    v10 --&gt; v11\n    v6 --&gt; v11\n    v11 --&gt; v13\n    v12 --&gt; v13\n    v13 --&gt; v15\n    v13 --&gt; v14\n\n\n\n\n\n\nIn a nutshell, nextflow will submit one or several SLURM job for each node in this graph, gather results, and produce some nice reports.",
    "crumbs": [
      "Introduction"
    ]
  },
  {
    "objectID": "01_intro.html#more-information",
    "href": "01_intro.html#more-information",
    "title": "Intro",
    "section": "More information",
    "text": "More information\nBoth nextflow and Julia have excellent and extensive documentation.\n\nNexflow documentation\nJulia documentation\n\nSee also this nextflow tutorial.",
    "crumbs": [
      "Introduction"
    ]
  },
  {
    "objectID": "03_create-exp-repo.html",
    "href": "03_create-exp-repo.html",
    "title": "Creating an experiment repo",
    "section": "",
    "text": "We use the term “experiment repo” for a git repository that contains the plumbing required for a numerical experiment.\nIt consists in a git repository with:\n\nthe nextflow executable and its configuration, nextflow.config;\na git submodule, nf-nest containing useful tools;\nyour .nf files and other supporting files.\n\nThis pages explains how to setup an experiment repo.",
    "crumbs": [
      "Create an experiment repo"
    ]
  },
  {
    "objectID": "03_create-exp-repo.html#overview",
    "href": "03_create-exp-repo.html#overview",
    "title": "Creating an experiment repo",
    "section": "",
    "text": "We use the term “experiment repo” for a git repository that contains the plumbing required for a numerical experiment.\nIt consists in a git repository with:\n\nthe nextflow executable and its configuration, nextflow.config;\na git submodule, nf-nest containing useful tools;\nyour .nf files and other supporting files.\n\nThis pages explains how to setup an experiment repo.",
    "crumbs": [
      "Create an experiment repo"
    ]
  },
  {
    "objectID": "03_create-exp-repo.html#location",
    "href": "03_create-exp-repo.html#location",
    "title": "Creating an experiment repo",
    "section": "Location",
    "text": "Location\nIn an HPC context, the experiment repo should be in a read/write location accessible to all nodes.\nFor example, on Sockeye the first choice if you allocation has it would be to use burst storage, i.e. cd to a path of the form\nexport JULIA_DEPOT_PATH=/arc/burst/[allocation_code]/[username_in_alloc]/\nA second choice would be to use the scratch space, i.e. cd to a path of the form\nexport JULIA_DEPOT_PATH=/scratch/[allocation_code]/[username_in_alloc]/",
    "crumbs": [
      "Create an experiment repo"
    ]
  },
  {
    "objectID": "03_create-exp-repo.html#sec-instructions",
    "href": "03_create-exp-repo.html#sec-instructions",
    "title": "Creating an experiment repo",
    "section": "Instructions",
    "text": "Instructions\nFor quick setup, run the following commands:\n\n# create a directory and cd into it\nmkdir experiment_repo && cd $_\n\ngit init\n\n# setup nextflow\ncurl -s https://get.nextflow.io | bash\n\n# add nf-nest utilities\ngit submodule add https://github.com/UBC-Stat-ML/nf-nest.git\n\n# copy template for nextflow configurations\ncp nf-nest/nextflow.config .",
    "crumbs": [
      "Create an experiment repo"
    ]
  },
  {
    "objectID": "05_pkg.html",
    "href": "05_pkg.html",
    "title": "Managing Julia packages on HPC",
    "section": "",
    "text": "Installing a package in Julia includes two steps (1) downloading (2) pre-compiling. In a laptop, both are done in one shot using\n]\nactivate experiment_repo/julia_env\nadd NameOfPackage\nIn an HPC setup, step (2) requires computational effort hence is best done in compute node. However in some HPC setups such as Sockeye, compute nodes do not have internet access, so the process needs to be split. We cover here some utilities that facilitate this.",
    "crumbs": [
      "Add Julia packages on HPC"
    ]
  },
  {
    "objectID": "05_pkg.html#overview",
    "href": "05_pkg.html#overview",
    "title": "Managing Julia packages on HPC",
    "section": "",
    "text": "Installing a package in Julia includes two steps (1) downloading (2) pre-compiling. In a laptop, both are done in one shot using\n]\nactivate experiment_repo/julia_env\nadd NameOfPackage\nIn an HPC setup, step (2) requires computational effort hence is best done in compute node. However in some HPC setups such as Sockeye, compute nodes do not have internet access, so the process needs to be split. We cover here some utilities that facilitate this.",
    "crumbs": [
      "Add Julia packages on HPC"
    ]
  },
  {
    "objectID": "05_pkg.html#julia-environment",
    "href": "05_pkg.html#julia-environment",
    "title": "Managing Julia packages on HPC",
    "section": "Julia environment",
    "text": "Julia environment\nA Julia environment is a specification of all package dependencies and their versions.\nBy convention, we will store it in a directory called experiment_repo/julia_env.",
    "crumbs": [
      "Add Julia packages on HPC"
    ]
  },
  {
    "objectID": "05_pkg.html#adding-a-package",
    "href": "05_pkg.html#adding-a-package",
    "title": "Managing Julia packages on HPC",
    "section": "Adding a package",
    "text": "Adding a package\nThere are two syntaxes in Julia to install packages: the interactive Julia package manager or using programmatic Pkg syntax. We cover both below.\nIn both syntaxes, we first need to tell Julia which environment to use. This is called “activating” an environment.\n\nInteractive Julia package manager\nThe most common method is to use the interactive Julia package manager. To start it, type ] followed by enter.\nActivating is done with the activate keyword.\nYou can then add a package using the add command. The argument of add can be either a registered Julia package, for example we show here how to add the Pigeons package for MCMC sampling:\nENV[\"JULIA_PKG_PRECOMPILE_AUTO\"]=0 # Hold off precompile since we are in login node\n]\nactivate experiment_repo/julia_env\nadd Pigeons\nAlternatively, the package can be a git repository, optionally with a specific commit/tag:\nadd Example@0.5\nadd Example#master\nadd Example#c37b675\nadd https://github.com/JuliaLang/Example.jl#master\nadd git@github.com:JuliaLang/Example.jl.git\nadd \"git@github.com:JuliaLang/Example.jl.git\"#master\nadd https://github.com/Company/MonoRepo:juliapkgs/Package.jl\nTo exit the interactive Julia package manager, type control-C.\n\n\nProgrammatic interface\nAlternatively, a programmatic interface is also available for scripting:\n\nENV[\"JULIA_PKG_PRECOMPILE_AUTO\"]=0 # Hold off precompile since we are in login node\nusing Pkg \nPkg.activate(\"experiment_repo/julia_env\")\nPkg.add(\"Pigeons\")",
    "crumbs": [
      "Add Julia packages on HPC"
    ]
  },
  {
    "objectID": "05_pkg.html#precompilation-on-hpc",
    "href": "05_pkg.html#precompilation-on-hpc",
    "title": "Managing Julia packages on HPC",
    "section": "Precompilation on HPC",
    "text": "Precompilation on HPC\nOnce we have downloaded the packages in the login node, we now turn to the task of performing pre-compilation.\n\ncd experiment_repo \n./nextflow run nf-nest/pkg.nf -profile cluster\n\nN E X T F L O W  ~  version 24.10.0\nLaunching `nf-nest/pkg.nf` [ridiculous_volta] DSL2 - revision: fc0374e695\n[a4/e6cda6] Submitted process &gt; instantiate_process\n[42/9bb2de] Submitted process &gt; precompile\n\n\nOptionally, you can append an argument to specify the number of threads to request and use during pre-compilation: e.g. add --nPrecompileThreads 20 to request 20 threads instead of the default of 10.",
    "crumbs": [
      "Add Julia packages on HPC"
    ]
  },
  {
    "objectID": "05_pkg.html#testing-your-julia-environment-interactively",
    "href": "05_pkg.html#testing-your-julia-environment-interactively",
    "title": "Managing Julia packages on HPC",
    "section": "Testing your Julia environment interactively",
    "text": "Testing your Julia environment interactively\nIn the code above, we have added the package Pigeons as an example.\nTo interactively test an installed package, simply activate the environment from a Julia session:\n\nusing Pkg\nPkg.activate(\"experiment_repo/julia_env\")\n\nusing Pigeons\npigeons(target = toy_mvn_target(1000))",
    "crumbs": [
      "Add Julia packages on HPC"
    ]
  },
  {
    "objectID": "05_pkg.html#more-information",
    "href": "05_pkg.html#more-information",
    "title": "Managing Julia packages on HPC",
    "section": "More information",
    "text": "More information\nSee Pkg.jl documentation.",
    "crumbs": [
      "Add Julia packages on HPC"
    ]
  },
  {
    "objectID": "08_containers.html",
    "href": "08_containers.html",
    "title": "Containers",
    "section": "",
    "text": "Containers such as Docker and apptainer address two issues:\n\nmaking pipeline reproducible,\nwe do not have root access in HPC.",
    "crumbs": [
      "Containers"
    ]
  },
  {
    "objectID": "08_containers.html#overview",
    "href": "08_containers.html#overview",
    "title": "Containers",
    "section": "",
    "text": "Containers such as Docker and apptainer address two issues:\n\nmaking pipeline reproducible,\nwe do not have root access in HPC.",
    "crumbs": [
      "Containers"
    ]
  },
  {
    "objectID": "08_containers.html#using-an-existing-container",
    "href": "08_containers.html#using-an-existing-container",
    "title": "Containers",
    "section": "Using an existing container",
    "text": "Using an existing container\nIn the file nextflow.config provided in nf-nest we provide an example of container documentation:\n\nhead -n 28 experiment_repo/nextflow.config\n\nprofiles {\n    standard {  \n        docker.enabled = true\n        process {\n            withLabel:containerized {\n                container = 'alexandrebouchardcote/default:0.1.6'\n            }\n        }\n    }\n    cluster {\n        apptainer.enabled = true\n        process {\n            scratch = true\n            executor = 'slurm'\n            cpus = 1\n            memory = 4.GB\n            time = '2h'\n            clusterOptions = \"--nodes=1 --account $ALLOCATION_CODE\"\n            withLabel:containerized {\n                container = 'alexandrebouchardcote/default:0.1.6'\n                module = 'apptainer'\n            }\n            withLabel:gpu {\n                clusterOptions = \"--nodes=1 --account ${ALLOCATION_CODE}-gpu --gpus 1\"\n            }\n        }\n    }\n}\n\n\nThere are two profiles, the default one using Docker, and the cluster one, using apptainer. We define a label for this container, which we call here containerized.\nTo instruct one of the process in the workflow to use that container, add the directive label 'containerized'.\nHere is an example of a process to compile and run a Stan program, where Stan is part of the above container:\n\nprocess compile_stan {\n    label 'containerized' \n\n    input:\n        path stan_file\n    output:\n        path \"${stan_file.baseName}\"\n        \n    \"\"\"\n    # name of stan file without extension\n    base_name=`basename $stan_file .stan`\n\n    # need to run Stan's make file from the CMDSTAN dir\n    CUR=`pwd`\n    cd \\$CMDSTAN\n    make \\$CUR/\\$base_name\n    \"\"\"\n}\n\nprocess run_stan {\n    label 'containerized' \n\n    input:\n        path stan_exec \n        path data\n\n    \"\"\"\n    ./$stan_exec sample \\\n        data file=$data \\\n        output file=samples.csv \n\n    # Compute ESS from Stan's stansummary utility\n    \\$CMDSTAN/bin/stansummary samples.csv --csv_filename ess.csv\n    \"\"\"\n}\n\nHere is an example workflow using these containerized processes:\n\ninclude { compile_stan; run_stan; } from \"./stan.nf\"\n\ndef stanModel = file(\"https://raw.githubusercontent.com/Julia-Tempering/Pigeons.jl/refs/heads/main/examples/stan/bernoulli.stan\")\ndef data = file(\"https://raw.githubusercontent.com/Julia-Tempering/Pigeons.jl/refs/heads/main/examples/stan/bernoulli.data.json\")\n\nworkflow {\n    compiled = compile_stan(stanModel)\n    run_stan(compiled, data)\n}\n\nTo run it:\n\ncd experiment_repo\n./nextflow run nf-nest/examples/stan_example.nf -profile cluster\n\nN E X T F L O W  ~  version 24.10.0\nLaunching `nf-nest/examples/stan_example.nf` [nice_hopper] DSL2 - revision: 8cef9f29d6\nWARN: Apptainer cache directory has not been defined -- Remote image will be stored in the path: /arc/burst/st-alexbou-1/abc/nf-nest-doc/experiment_repo/work/singularity -- Use the environment variable NXF_APPTAINER_CACHEDIR to specify a different location\nPulling Apptainer image docker://alexandrebouchardcote/default:0.1.6 [cache /arc/burst/st-alexbou-1/abc/nf-nest-doc/experiment_repo/work/singularity/alexandrebouchardcote-default-0.1.6.img]\n[0e/d322db] Submitted process &gt; compile_stan\n[0a/6f5de1] Submitted process &gt; run_stan",
    "crumbs": [
      "Containers"
    ]
  },
  {
    "objectID": "08_containers.html#creating-containers",
    "href": "08_containers.html#creating-containers",
    "title": "Containers",
    "section": "Creating containers",
    "text": "Creating containers\nThere are many reference online for creating containers in general, but much less on creating cross-platform containers working on both x86 and Apple Silicon.\nWe have created some script to help doing this, see code and instructions at this page.",
    "crumbs": [
      "Containers"
    ]
  },
  {
    "objectID": "07_combine.html",
    "href": "07_combine.html",
    "title": "Combine outputs",
    "section": "",
    "text": "Now that we know how to run many jobs, the next question is how to combine the output of all these jobs to analyze it.",
    "crumbs": [
      "Combine outputs"
    ]
  },
  {
    "objectID": "07_combine.html#overview",
    "href": "07_combine.html#overview",
    "title": "Combine outputs",
    "section": "",
    "text": "Now that we know how to run many jobs, the next question is how to combine the output of all these jobs to analyze it.",
    "crumbs": [
      "Combine outputs"
    ]
  },
  {
    "objectID": "07_combine.html#example",
    "href": "07_combine.html#example",
    "title": "Combine outputs",
    "section": "Example",
    "text": "Example\nWe will run Pigeons on the cross product formed by calling crossProduct(variables) with:\ndef variables = [\n    seed: 1..10,\n    n_chains: [10, 20], \n]\nSuppose we want to create a plot from the output of these 20 Julia processes.",
    "crumbs": [
      "Combine outputs"
    ]
  },
  {
    "objectID": "07_combine.html#strategy",
    "href": "07_combine.html#strategy",
    "title": "Combine outputs",
    "section": "Strategy",
    "text": "Strategy\nEach Julia process will create a folder. Using a function, we will provide an automatic name to this folder encoding the inputs used (seed and n_chains). That name is provided by nf-nest’s filed() function. In that folder, we will\nput csv files.\nThen, once all Julia processes are done, another utilities from nf-nest, combine_csvs, will merge all CSVs while adding columns for the inputs (here, seed and n_chains).\nFinally, we will pass the merged CSVs to a plotting process.",
    "crumbs": [
      "Combine outputs"
    ]
  },
  {
    "objectID": "07_combine.html#nextflow-script",
    "href": "07_combine.html#nextflow-script",
    "title": "Combine outputs",
    "section": "Nextflow script",
    "text": "Nextflow script\n\n// includes are relative to the .nf file, should always start with ./ or ../\ninclude { crossProduct; filed; deliverables } from '../cross.nf'\ninclude { instantiate; precompile; activate } from '../pkg.nf'\ninclude { combine_csvs; } from '../combine.nf'\n\n// in contrast, file(..) is relative to `pwd`, use projectDir/ \n//   to make it relative to main .nf file, or moduleDir for the .nf file\ndef julia_env = file(moduleDir/'julia_env')\ndef plot_script = file(moduleDir/'plot.jl')\n\ndef variables = [\n    seed: 1..10,\n    n_chains: [10, 20], \n]\n\nworkflow {\n    compiled_env = instantiate(julia_env) | precompile\n    configs = crossProduct(variables)\n    combined = run_julia(compiled_env, configs) | combine_csvs\n    plot(compiled_env, plot_script, combined)\n}\n\nprocess run_julia {\n    input:\n        path julia_env \n        val config \n    output:\n        path \"${filed(config)}\"\n    \"\"\"\n    ${activate(julia_env)}\n\n    # run your code\n    using Pigeons \n    using CSV \n    pt = pigeons(\n            target = toy_mvn_target(1000), \n            n_chains = ${config.n_chains}, \n            seed = ${config.seed})\n\n    # organize output as follows:\n    #   - create a directory with name controlled by filed(config)\n    #     to keep track of input configuration\n    #   - put any number of CSV in there\n    mkdir(\"${filed(config)}\")\n    CSV.write(\"${filed(config)}/summary.csv\", pt.shared.reports.summary)\n    CSV.write(\"${filed(config)}/swap_prs.csv\", pt.shared.reports.swap_prs)\n    \"\"\"\n}\n\nprocess plot {\n    input:\n        path julia_env \n        path plot_script\n        path combined_csvs_folder \n    output:\n        path '*.png'\n        path combined_csvs_folder\n    publishDir \"${deliverables(workflow, params)}\", mode: 'copy', overwrite: true\n    \"\"\"\n    ${activate(julia_env)}\n\n    include(\"$plot_script\")\n    create_plots(\"$combined_csvs_folder\")\n    \"\"\"\n}",
    "crumbs": [
      "Combine outputs"
    ]
  },
  {
    "objectID": "07_combine.html#running-the-nextflow-script",
    "href": "07_combine.html#running-the-nextflow-script",
    "title": "Combine outputs",
    "section": "Running the nextflow script",
    "text": "Running the nextflow script\n\ncd experiment_repo\n./nextflow run nf-nest/examples/full.nf -profile cluster \n\nN E X T F L O W  ~  version 24.10.0\nLaunching `nf-nest/examples/full.nf` [golden_poitras] DSL2 - revision: a68c131baa\n[8c/a117a8] Submitted process &gt; instantiate_process\n[5f/997727] Submitted process &gt; combine_workflow:instantiate_process\n[72/cc3bb2] Submitted process &gt; precompile\n[b9/57c5b2] Submitted process &gt; combine_workflow:precompile\n[42/f159a5] Submitted process &gt; run_julia (13)\n[bc/98503a] Submitted process &gt; run_julia (10)\n[4d/bd3f1f] Submitted process &gt; run_julia (1)\n[c6/c5473f] Submitted process &gt; run_julia (7)\n[9c/4051ca] Submitted process &gt; run_julia (5)\n[c1/2cb9ec] Submitted process &gt; run_julia (11)\n[6d/af7d1f] Submitted process &gt; run_julia (16)\n[a2/78b5dc] Submitted process &gt; run_julia (8)\n[47/65c526] Submitted process &gt; run_julia (14)\n[9b/e1998e] Submitted process &gt; run_julia (12)\n[65/c7c28f] Submitted process &gt; run_julia (6)\n[07/9f3d4c] Submitted process &gt; run_julia (2)\n[13/27eb7d] Submitted process &gt; run_julia (3)\n[95/88b5e1] Submitted process &gt; run_julia (9)\n[33/81cb06] Submitted process &gt; run_julia (19)\n[e4/7dc064] Submitted process &gt; run_julia (17)\n[50/cb53b6] Submitted process &gt; run_julia (4)\n[44/c2c487] Submitted process &gt; run_julia (15)\n[b9/05c738] Submitted process &gt; run_julia (20)\n[c9/0e2573] Submitted process &gt; run_julia (18)\n[cf/4b324f] Submitted process &gt; combine_workflow:combine_process\n[ff/ab4541] Submitted process &gt; plot",
    "crumbs": [
      "Combine outputs"
    ]
  },
  {
    "objectID": "07_combine.html#accessing-the-output",
    "href": "07_combine.html#accessing-the-output",
    "title": "Combine outputs",
    "section": "Accessing the output",
    "text": "Accessing the output\nEach nextflow process is associated with a unique work directory to ensure the processes do not interfere with each other. Here we cover two ways to quickly access these work directories.\n\nQuick inspection\nA quick way to find the output of a nextflow process that we just ran is to use:\ncd experiment_repo \nnf-nest/nf-open\nThis lists the work folders for the last nextflow job.\n\n\nOrganizing the output with a publishDir\nA better approach is to use the publishDir directive, combined with nf-nest’s deliverables() utility, as illustrated in the run_julia process above. This will automatically copy the output of the process associated with the directive in a sub-directory of experiment_repo/deliverables.\n\ncd experiment_repo\ntree deliverables\n\ndeliverables\n└── scriptName=full.nf\n    ├── output\n    │   ├── summary.csv\n    │   └── swap_prs.csv\n    ├── plot.png\n    └── runName.txt\n\n2 directories, 4 files\n\n\nHere the contents of runName.txt can be used with nextflow’s log command to obtain more information on the run.\n\ncat deliverables/scriptName=full.nf/runName.txt \n\ngolden_poitras\n\n\n\n./nextflow log\n\nTIMESTAMP           DURATION    RUN NAME            STATUS  REVISION ID SESSION ID                              COMMAND                                                       \n2024-11-12 12:05:21 5.8s        angry_northcutt     OK      9d1a692a7e  2e019c7d-7c4e-42e5-b142-1dd6770fcb61    nextflow run nf-nest/examples/hello.nf                        \n2024-11-12 12:05:33 8.6s        wise_goldberg       OK      9d1a692a7e  2e019c7d-7c4e-42e5-b142-1dd6770fcb61    nextflow run nf-nest/examples/hello.nf -profile cluster       \n2024-11-12 12:06:36 1m 20s      ridiculous_volta    OK      fc0374e695  2e019c7d-7c4e-42e5-b142-1dd6770fcb61    nextflow run nf-nest/pkg.nf -profile cluster                  \n2024-11-12 12:08:22 1m 39s      elegant_fermi       OK      aa082b1978  2e019c7d-7c4e-42e5-b142-1dd6770fcb61    nextflow run nf-nest/examples/many_jobs.nf -profile cluster   \n2024-11-12 12:10:07 6.5s        tiny_elion          OK      d9de661ecc  2e019c7d-7c4e-42e5-b142-1dd6770fcb61    nextflow run nf-nest/examples/filter.nf                       \n2024-11-12 12:10:24 2m 19s      nice_hopper         OK      8cef9f29d6  2e019c7d-7c4e-42e5-b142-1dd6770fcb61    nextflow run nf-nest/examples/stan_example.nf -profile cluster\n2024-11-12 12:13:41 34.7s       clever_neumann      OK      713b74ac4a  2e019c7d-7c4e-42e5-b142-1dd6770fcb61    nextflow run nf-nest/pkg_gpu.nf                               \n2024-11-12 12:14:22 1m 50s      voluminous_coulomb  OK      9be41cea49  2e019c7d-7c4e-42e5-b142-1dd6770fcb61    nextflow run nf-nest/examples/gpu.nf -profile cluster         \n2024-11-12 12:16:23 6m 26s      golden_poitras      OK      a68c131baa  2e019c7d-7c4e-42e5-b142-1dd6770fcb61    nextflow run nf-nest/examples/full.nf -profile cluster        \n\n\nAnd we can see in the CSV that indeed the columns seed and n_chains were added to the left:\n\nhead -n 2 deliverables/scriptName=full.nf/output/summary.csv \n\nseed,n_chains,round,n_scans,n_tempered_restarts,global_barrier,global_barrier_variational,last_round_max_time,last_round_max_allocation,stepping_stone\n10,10,1,2,,8.998207738433418,,0.000288568,13536.0,-1173.429270641805",
    "crumbs": [
      "Combine outputs"
    ]
  }
]