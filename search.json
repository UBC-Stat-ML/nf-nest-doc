[
  {
    "objectID": "09_gpu.html",
    "href": "09_gpu.html",
    "title": "GPU programming",
    "section": "",
    "text": "In a context such as Sockeye where it is not possible to access GPU nodes with internet access, precompilation becomes more complicated than the earlier page on non-CUDA precompilation.\nWe provide a workaround, pkg_gpu.nf, which offers the same functionality as pkg.nf but is slower since all precompilation has to occur on the login node.\nFirst, add the package as before:\n\nENV[\"JULIA_PKG_PRECOMPILE_AUTO\"]=0 # Hold off precompile since we are in login node\nusing Pkg \nPkg.activate(\"experiment_repo/julia_env\")\nPkg.add(\"CUDA\")\n\nNext, use the GPU precompilation script:\n\ncd experiment_repo \n./nextflow run nf-nest/pkg_gpu.nf \n\nN E X T F L O W  ~  version 24.10.0\nLaunching `nf-nest/pkg_gpu.nf` [mad_goldstine] DSL2 - revision: 713b74ac4a\n[49/394bf6] Submitted process &gt; instantiate_process\n[b1/e64f5a] Submitted process &gt; precompile_gpu",
    "crumbs": [
      "GPU programming"
    ]
  },
  {
    "objectID": "09_gpu.html#installing-cuda.jl",
    "href": "09_gpu.html#installing-cuda.jl",
    "title": "GPU programming",
    "section": "",
    "text": "In a context such as Sockeye where it is not possible to access GPU nodes with internet access, precompilation becomes more complicated than the earlier page on non-CUDA precompilation.\nWe provide a workaround, pkg_gpu.nf, which offers the same functionality as pkg.nf but is slower since all precompilation has to occur on the login node.\nFirst, add the package as before:\n\nENV[\"JULIA_PKG_PRECOMPILE_AUTO\"]=0 # Hold off precompile since we are in login node\nusing Pkg \nPkg.activate(\"experiment_repo/julia_env\")\nPkg.add(\"CUDA\")\n\nNext, use the GPU precompilation script:\n\ncd experiment_repo \n./nextflow run nf-nest/pkg_gpu.nf \n\nN E X T F L O W  ~  version 24.10.0\nLaunching `nf-nest/pkg_gpu.nf` [mad_goldstine] DSL2 - revision: 713b74ac4a\n[49/394bf6] Submitted process &gt; instantiate_process\n[b1/e64f5a] Submitted process &gt; precompile_gpu",
    "crumbs": [
      "GPU programming"
    ]
  },
  {
    "objectID": "09_gpu.html#running-nextflow-processes-requiring-gpu",
    "href": "09_gpu.html#running-nextflow-processes-requiring-gpu",
    "title": "GPU programming",
    "section": "Running nextflow processes requiring GPU",
    "text": "Running nextflow processes requiring GPU\nAn example of a workflow using GPUs:\n\ninclude { instantiate; precompile_gpu; } from \"../pkg_gpu.nf\"\ninclude { activate; } from \"../pkg.nf\"\n\ndef julia_env = file('julia_env')\n\nworkflow {\n    instantiate(julia_env) | precompile_gpu | run_julia\n}\n\nprocess run_julia {\n    debug true\n    label 'gpu'\n    input:\n        path julia_env\n    \"\"\"\n    ${activate(julia_env)}\n\n    using CUDA \n\n    println(\"CPU\")\n    x = rand(5000, 5000);\n    @time x * x;\n    @time x * x;\n\n    println(\"GPU\")\n    x = CUDA.rand(5000, 5000);\n    @time x * x;\n    @time x * x;\n\n    CUDA.versioninfo()\n    \"\"\"\n}\n\nWe run it using the same command as usual:\n\ncd experiment_repo\n./nextflow run nf-nest/examples/gpu.nf -profile cluster\n\nN E X T F L O W  ~  version 24.10.0\nLaunching `nf-nest/examples/gpu.nf` [happy_goldberg] DSL2 - revision: 9be41cea49\n[be/5a7e4e] Submitted process &gt; instantiate_process\n[c5/2f10a1] Submitted process &gt; precompile_gpu\n[85/0c764a] Submitted process &gt; run_julia\nCPU\n 13.170952 seconds (4.79 M allocations: 517.701 MiB, 3.76% gc time, 17.14% compilation time)\n 10.471519 seconds (2 allocations: 190.735 MiB, 0.07% gc time)\nGPU\n  1.527329 seconds (1.67 M allocations: 107.375 MiB, 96.08% compilation time)\n  0.000572 seconds (50 allocations: 1.172 KiB)\nCUDA runtime 12.5, artifact installation\nCUDA driver 12.6\nNVIDIA driver 550.90.12\n\nCUDA libraries: \n- CUBLAS: 12.5.3\n- CURAND: 10.3.6\n- CUFFT: 11.2.3\n- CUSOLVER: 11.6.3\n- CUSPARSE: 12.5.1\n- CUPTI: 2024.2.1 (API 23.0.0)\n- NVML: 12.0.0+550.90.12\n\nJulia packages: \n- CUDA: 5.5.2\n- CUDA_Driver_jll: 0.10.3+0\n- CUDA_Runtime_jll: 0.15.3+0\n\nToolchain:\n- Julia: 1.10.2\n- LLVM: 15.0.7\n\nPreferences:\n- CUDA_Runtime_jll.version: 12.5\n\n1 device:\n  0: Tesla V100-SXM2-32GB (sm_70, 31.137 GiB / 32.000 GiB available)",
    "crumbs": [
      "GPU programming"
    ]
  },
  {
    "objectID": "09_gpu.html#gpu-kernel-development",
    "href": "09_gpu.html#gpu-kernel-development",
    "title": "GPU programming",
    "section": "GPU kernel development",
    "text": "GPU kernel development\nOne way to leverage GPUs is to use array programming as demonstrated in the example above. When a problem cannot be cast into an array problem, an alternative is to construct a custom GPU kernel.\nDesigning custom GPU kernels is especially attractive in Julia. This is in big part thanks to\nKernelAbstractions.jl, which allows the same code to be emit both CPU and GPU versions. Since error messages are easier to interpret when doing CPU development, it is useful to be able to test both CPU and GPU targets.\nCompared to Julia CPU development, the main constraint when doing GPU development is that inside the kernel there should not be heap allocations. Seasoned Julia developers are often already often avoiding to allocate in the inner loop due to garbage collection costs.\nFor a concrete example of KernelAbstractions.jl in action, see these kernels used to implement Sequential Annealed Importance Sampling.",
    "crumbs": [
      "GPU programming"
    ]
  },
  {
    "objectID": "07_combine.html",
    "href": "07_combine.html",
    "title": "Combine outputs",
    "section": "",
    "text": "Now that we know how to run many jobs, the next question is how to combine the output of all these jobs to analyze it.",
    "crumbs": [
      "Combine outputs"
    ]
  },
  {
    "objectID": "07_combine.html#overview",
    "href": "07_combine.html#overview",
    "title": "Combine outputs",
    "section": "",
    "text": "Now that we know how to run many jobs, the next question is how to combine the output of all these jobs to analyze it.",
    "crumbs": [
      "Combine outputs"
    ]
  },
  {
    "objectID": "07_combine.html#example",
    "href": "07_combine.html#example",
    "title": "Combine outputs",
    "section": "Example",
    "text": "Example\nWe will run Pigeons on the cross product formed by calling crossProduct(variables) with:\ndef variables = [\n    seed: 1..10,\n    n_chains: [10, 20], \n]\nSuppose we want to create a plot from the output of these 20 Julia processes.",
    "crumbs": [
      "Combine outputs"
    ]
  },
  {
    "objectID": "07_combine.html#strategy",
    "href": "07_combine.html#strategy",
    "title": "Combine outputs",
    "section": "Strategy",
    "text": "Strategy\nEach Julia process will create a folder. Using a function, we will provide an automatic name to this folder encoding the inputs used (seed and n_chains). That name is provided by nf-nest’s filed() function. In that folder, we will\nput csv files.\nThen, once all Julia processes are done, another utilities from nf-nest, combine_csvs, will merge all CSVs while adding columns for the inputs (here, seed and n_chains).\nFinally, we will pass the merged CSVs to a plotting process.",
    "crumbs": [
      "Combine outputs"
    ]
  },
  {
    "objectID": "07_combine.html#nextflow-script",
    "href": "07_combine.html#nextflow-script",
    "title": "Combine outputs",
    "section": "Nextflow script",
    "text": "Nextflow script\n\n// includes are relative to the .nf file, should always start with ./ or ../\ninclude { crossProduct; filed; deliverables } from '../cross.nf'\ninclude { instantiate; precompile; activate } from '../pkg.nf'\ninclude { combine_csvs; } from '../combine.nf'\n\n// in contrast, file(..) is relative to `pwd`, use projectDir/ \n//   to make it relative to main .nf file, or moduleDir for the .nf file\ndef julia_env = file(moduleDir/'julia_env')\ndef plot_script = file(moduleDir/'plot.jl')\n\ndef variables = [\n    seed: 1..10,\n    n_chains: [10, 20], \n]\n\nworkflow {\n    compiled_env = instantiate(julia_env) | precompile\n    configs = crossProduct(variables)\n    combined = run_julia(compiled_env, configs) | combine_csvs\n    plot(compiled_env, plot_script, combined)\n}\n\nprocess run_julia {\n    input:\n        path julia_env \n        val config \n    output:\n        path \"${filed(config)}\"\n    \"\"\"\n    ${activate(julia_env)}\n\n    # run your code\n    using Pigeons \n    using CSV \n    pt = pigeons(\n            target = toy_mvn_target(1000), \n            n_chains = ${config.n_chains}, \n            seed = ${config.seed})\n\n    # organize output as follows:\n    #   - create a directory with name controlled by filed(config)\n    #     to keep track of input configuration\n    #   - put any number of CSV in there\n    mkdir(\"${filed(config)}\")\n    CSV.write(\"${filed(config)}/summary.csv\", pt.shared.reports.summary)\n    CSV.write(\"${filed(config)}/swap_prs.csv\", pt.shared.reports.swap_prs)\n    \"\"\"\n}\n\nprocess plot {\n    input:\n        path julia_env \n        path plot_script\n        path combined_csvs_folder \n    output:\n        path '*.png'\n        path combined_csvs_folder\n    publishDir \"${deliverables(workflow, params)}\", mode: 'copy', overwrite: true\n    \"\"\"\n    ${activate(julia_env)}\n\n    include(\"$plot_script\")\n    create_plots(\"$combined_csvs_folder\")\n    \"\"\"\n}",
    "crumbs": [
      "Combine outputs"
    ]
  },
  {
    "objectID": "07_combine.html#running-the-nextflow-script",
    "href": "07_combine.html#running-the-nextflow-script",
    "title": "Combine outputs",
    "section": "Running the nextflow script",
    "text": "Running the nextflow script\n\ncd experiment_repo\n./nextflow run nf-nest/examples/full.nf -profile cluster \n\nN E X T F L O W  ~  version 24.10.0\nLaunching `nf-nest/examples/full.nf` [gloomy_bardeen] DSL2 - revision: a68c131baa\n[e6/bd72b0] Submitted process &gt; combine_workflow:instantiate_process\n[90/17eb99] Submitted process &gt; instantiate_process\n[25/e00629] Submitted process &gt; precompile\n[c6/fe533e] Submitted process &gt; combine_workflow:precompile\n[d7/6278f0] Submitted process &gt; run_julia (1)\n[95/26225c] Submitted process &gt; run_julia (12)\n[f4/c2cfc4] Submitted process &gt; run_julia (11)\n[72/daab8f] Submitted process &gt; run_julia (15)\n[13/c967f1] Submitted process &gt; run_julia (2)\n[1b/620546] Submitted process &gt; run_julia (6)\n[58/4cf41c] Submitted process &gt; run_julia (7)\n[88/dc6041] Submitted process &gt; run_julia (10)\n[ec/0b8ff7] Submitted process &gt; run_julia (3)\n[85/3f52e3] Submitted process &gt; run_julia (13)\n[7a/da04ae] Submitted process &gt; run_julia (8)\n[65/94d65f] Submitted process &gt; run_julia (16)\n[e5/613077] Submitted process &gt; run_julia (5)\n[4b/8734be] Submitted process &gt; run_julia (14)\n[d6/0b5cc7] Submitted process &gt; run_julia (4)\n[60/5c6106] Submitted process &gt; run_julia (9)\n[44/070feb] Submitted process &gt; run_julia (18)\n[bb/a2be64] Submitted process &gt; run_julia (17)\n[5c/c1f32d] Submitted process &gt; run_julia (20)\n[f3/9bf9d2] Submitted process &gt; run_julia (19)\n[66/ec5b2f] Submitted process &gt; combine_workflow:combine_process\n[6d/e06477] Submitted process &gt; plot",
    "crumbs": [
      "Combine outputs"
    ]
  },
  {
    "objectID": "07_combine.html#accessing-the-output",
    "href": "07_combine.html#accessing-the-output",
    "title": "Combine outputs",
    "section": "Accessing the output",
    "text": "Accessing the output\nEach nextflow process is associated with a unique work directory to ensure the processes do not interfere with each other. Here we cover two ways to quickly access these work directories.\n\nQuick inspection\nA quick way to find the output of a nextflow process that we just ran is to use:\ncd experiment_repo \nnf-nest/nf-open\nThis lists the work folders for the last nextflow job.\n\n\nOrganizing the output with a publishDir\nA better approach is to use the publishDir directive, combined with nf-nest’s deliverables() utility, as illustrated in the run_julia process above. This will automatically copy the output of the process associated with the directive in a sub-directory of experiment_repo/deliverables.\n\ntree experiment_repo/deliverables\n\nexperiment_repo/deliverables\n└── scriptName=full.nf___runName=gloomy_bardeen\n    ├── output\n    │   ├── summary.csv\n    │   └── swap_prs.csv\n    └── plot.png\n\n2 directories, 3 files\n\n\nHere the runName can be used with nextflow’s log command to obtain more information on the run.\n\ncd experiment_repo\n./nextflow log\n\nTIMESTAMP           DURATION    RUN NAME            STATUS  REVISION ID SESSION ID                              COMMAND                                                \n2024-11-11 20:52:00 3.1s        insane_wegener      OK      9d1a692a7e  9579116d-1e95-4a32-b13a-14c9f7370dee    nextflow run nf-nest/examples/hello.nf                 \n2024-11-11 20:52:07 7.4s        voluminous_banach   OK      9d1a692a7e  9579116d-1e95-4a32-b13a-14c9f7370dee    nextflow run nf-nest/examples/hello.nf -profile cluster\n2024-11-11 20:53:06 47.7s       reverent_curran     OK      fc0374e695  9579116d-1e95-4a32-b13a-14c9f7370dee    nextflow run nf-nest/pkg.nf -profile cluster           \n2024-11-11 20:54:16 5m 49s      gloomy_bardeen      OK      a68c131baa  9579116d-1e95-4a32-b13a-14c9f7370dee    nextflow run nf-nest/examples/full.nf -profile cluster",
    "crumbs": [
      "Combine outputs"
    ]
  },
  {
    "objectID": "04_launch.html",
    "href": "04_launch.html",
    "title": "Launching an experiment",
    "section": "",
    "text": "We show how to launch an “experiment”, i.e., a nextflow script.\nWe cover two ways to launch an experiment:\n\nLocal: where all processes (nodes in the workflow graph) run in the same machine.\nCluster where each node in the graph can run in different machines in a cluster.\n\nMethod 1 is useful to run experiments on a laptop and for prototyping.\nSurprisingly, thanks to nextflow, method 2 only involves adding the command line option -profile cluster. This is because nextflow takes care of generating submission scripts, transferring files and orchestring everything.",
    "crumbs": [
      "Launch an experiment"
    ]
  },
  {
    "objectID": "04_launch.html#overview",
    "href": "04_launch.html#overview",
    "title": "Launching an experiment",
    "section": "",
    "text": "We show how to launch an “experiment”, i.e., a nextflow script.\nWe cover two ways to launch an experiment:\n\nLocal: where all processes (nodes in the workflow graph) run in the same machine.\nCluster where each node in the graph can run in different machines in a cluster.\n\nMethod 1 is useful to run experiments on a laptop and for prototyping.\nSurprisingly, thanks to nextflow, method 2 only involves adding the command line option -profile cluster. This is because nextflow takes care of generating submission scripts, transferring files and orchestring everything.",
    "crumbs": [
      "Launch an experiment"
    ]
  },
  {
    "objectID": "04_launch.html#example-nextflow-script",
    "href": "04_launch.html#example-nextflow-script",
    "title": "Launching an experiment",
    "section": "Example nextflow script",
    "text": "Example nextflow script\nThe nf-nest repo contains a small example nextflow script, which we will use to demonstrate the two ways to launch an experiment. Here is the script for reference:\n\nworkflow  {\n    hello()\n}\n\nprocess hello {\n    debug true \n    \"\"\"\n    echo Hello world!\n    \"\"\"\n}",
    "crumbs": [
      "Launch an experiment"
    ]
  },
  {
    "objectID": "04_launch.html#local-execution",
    "href": "04_launch.html#local-execution",
    "title": "Launching an experiment",
    "section": "Local execution",
    "text": "Local execution\nUse the following command to run the nextflow script locally:\n\ncd experiment_repo\n./nextflow run nf-nest/examples/hello.nf\n\nN E X T F L O W  ~  version 24.10.0\nWARN: It appears you have never run this project before -- Option `-resume` is ignored\nLaunching `nf-nest/examples/hello.nf` [insane_wegener] DSL2 - revision: 9d1a692a7e\n[df/47fcee] Submitted process &gt; hello\nHello world!",
    "crumbs": [
      "Launch an experiment"
    ]
  },
  {
    "objectID": "04_launch.html#cluster-execution",
    "href": "04_launch.html#cluster-execution",
    "title": "Launching an experiment",
    "section": "Cluster execution",
    "text": "Cluster execution\nTo run on a cluster, add the argument -profile cluster which instructs nextflow to use the configs in section cluster { ... } of the file nextflow.config created in the setup instructions.1\nHere is a minimal example:\n\n./nextflow run nf-nest/examples/hello.nf -profile cluster \n\nN E X T F L O W  ~  version 24.10.0\nLaunching `nf-nest/examples/hello.nf` [voluminous_banach] DSL2 - revision: 9d1a692a7e\n[df/47fcee] Cached process &gt; hello\nHello world!",
    "crumbs": [
      "Launch an experiment"
    ]
  },
  {
    "objectID": "04_launch.html#managing-long-executions",
    "href": "04_launch.html#managing-long-executions",
    "title": "Launching an experiment",
    "section": "Managing long executions",
    "text": "Managing long executions\nWhen starting a job, the launching nextflow process needs to stay alive until the end of the last job. However, when the SSH connection is lost (e.g., you close your laptop), the nextflow process and hence child jobs will be killed. To avoid this, use screen or tmux which allows you to preserve a SSH session even if the SSH connection is closed.\n\nBasic instructions to start a long job\n\nTake note of which of the login nodes you are starting the job (e.g. in Sockeye, login01, login02 or login03).\nList existing tmux sessions with tmux ls\nCreate one with tmux or join last one with tmux a\nStart the nextflow.\nTo detach the tmux session ctrl-b followed by d\n\n\n\nLook at the status after being disconnected\n\nSSH in.\nIf you are in the wrong login node, use e.g., ssh login02 (follow 2FA instruction)\nReattach with tmux a\n\nFor more information on tmux, use this cheat sheet.\n\n\nCancelling a nextflow workflow\nPress ctrl-c only once. This will instruct nextflow to clean up children jobs: killing running jobs, as well as cancelling queued jobs.",
    "crumbs": [
      "Launch an experiment"
    ]
  },
  {
    "objectID": "04_launch.html#footnotes",
    "href": "04_launch.html#footnotes",
    "title": "Launching an experiment",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nIn the previous section (“local execution”), where we did not specify a -profile, the default profile named standard is used.↩︎",
    "crumbs": [
      "Launch an experiment"
    ]
  },
  {
    "objectID": "02_setup.html",
    "href": "02_setup.html",
    "title": "Setting up your HPC account",
    "section": "",
    "text": "You will need to go through these setup instructions before using nf-nest. This needs to be done only once per user and per cluster.",
    "crumbs": [
      "Setup your HPC account"
    ]
  },
  {
    "objectID": "02_setup.html#overview",
    "href": "02_setup.html#overview",
    "title": "Setting up your HPC account",
    "section": "",
    "text": "You will need to go through these setup instructions before using nf-nest. This needs to be done only once per user and per cluster.",
    "crumbs": [
      "Setup your HPC account"
    ]
  },
  {
    "objectID": "02_setup.html#prerequisites",
    "href": "02_setup.html#prerequisites",
    "title": "Setting up your HPC account",
    "section": "Prerequisites",
    "text": "Prerequisites\n\nWorking knowledge of unix (files, permissions, processes, environment variables).\nWorking knowledge of git.\n\nThere are countless web resources to learn those things. Tedious but worth the investment.",
    "crumbs": [
      "Setup your HPC account"
    ]
  },
  {
    "objectID": "02_setup.html#optional-password-less-ssh",
    "href": "02_setup.html#optional-password-less-ssh",
    "title": "Setting up your HPC account",
    "section": "Optional: Password-less SSH",
    "text": "Optional: Password-less SSH\nIt is imperative for your sanity to avoid entering your password and do 2FA every time a SSH connection is needed.\nFor example, on Sockeye, the closest you can get to that is with SSH Connection Sharing. This means that you open a first terminal window and perform 2FA in it. As long as that window is open, other SSH connections can be established without password and 2FA. Minimize that first window and do not touch it.",
    "crumbs": [
      "Setup your HPC account"
    ]
  },
  {
    "objectID": "02_setup.html#optional-install-vs-code",
    "href": "02_setup.html#optional-install-vs-code",
    "title": "Setting up your HPC account",
    "section": "Optional: Install VS Code",
    "text": "Optional: Install VS Code\nVS Code makes it easier to develop on a remote server. For example, it simplifies file editing, resuming your session, manages github credential for you, etc.\n\nOn your laptop, install VSCode.\nFollow two steps documented in the VS Code website\n\nInstall the SSH extension\nClick on the Remote SSH icon in the lower left, this will let you Connect to Remote Host.\n\n\nUse New Terminal to open a terminal. Once you have a project (git repo) where you develop ready, use Open Folder... to point VS Code to the root of your project. VS Code is also able to manage your github authentification.",
    "crumbs": [
      "Setup your HPC account"
    ]
  },
  {
    "objectID": "02_setup.html#understanding-start-up-files",
    "href": "02_setup.html#understanding-start-up-files",
    "title": "Setting up your HPC account",
    "section": "Understanding start up files",
    "text": "Understanding start up files\nBash (and its cousins such as zsh) are used in two main ways:\n\nWhen you login via SSH.\nAfter being logged in, bash can be called by another process (e.g. bash, VS Code).\n\nVS Code internally uses 1 once but hides it, and when a new terminal in VS Code is opened, it is done via 2.\nWhen bash is started with 1, the file ~/.bash_profile is called. When bash is started with 2, the file ~/.bashrc is sometimes called.1\nSince we do 2 more frequently, we want it to be fast. It is OK if some operations in 1 are a bit slow because it is less frequently called.\nTypically anything in 2 we want it to happen in 1 as well. So use this:\n# put that in .bash_profile so that anything in .bashrc also gets loaded\nif [ -f ~/.bashrc ]; then\n    . ~/.bashrc\nfi\nRecall that any environment variables with export are passed in to child process. So no need to set them every time in 2, instead you can set them once and for all in 1 (but then you need to login again for this take effect).\nOn the other hand, aything with alias, module, etc, is not propagated.",
    "crumbs": [
      "Setup your HPC account"
    ]
  },
  {
    "objectID": "02_setup.html#git",
    "href": "02_setup.html#git",
    "title": "Setting up your HPC account",
    "section": "Git",
    "text": "Git\nWe assume the command git is available.\nIn some HPC such as UBC Sockeye, this command is not available by default, instead a module has to be loaded:\n\nmodule load git",
    "crumbs": [
      "Setup your HPC account"
    ]
  },
  {
    "objectID": "02_setup.html#allocation-code",
    "href": "02_setup.html#allocation-code",
    "title": "Setting up your HPC account",
    "section": "Allocation code",
    "text": "Allocation code\nIn some HPC such as UBC Sockeye, we need an allocation code to submit to the job queue. Scripts in nf-nest use an ENV variable called ALLOCATION_CODE to find the allocation code.\nTo set the variable in your current session, use:\n\nexport ALLOCATION_CODE=my-alloc-code",
    "crumbs": [
      "Setup your HPC account"
    ]
  },
  {
    "objectID": "02_setup.html#optional-disable-nextflow-fancy-output",
    "href": "02_setup.html#optional-disable-nextflow-fancy-output",
    "title": "Setting up your HPC account",
    "section": "Optional: disable nextflow fancy output",
    "text": "Optional: disable nextflow fancy output\nIt can be useful to avoid nextflow’s fancy progress output, for example they do not work well in notebook or in screen.\nTo disable in the current session, use:\n\nexport NXF_ANSI_LOG=false",
    "crumbs": [
      "Setup your HPC account"
    ]
  },
  {
    "objectID": "02_setup.html#java",
    "href": "02_setup.html#java",
    "title": "Setting up your HPC account",
    "section": "Java",
    "text": "Java\nNextflow needs Java. Follow these instructions taken from the nextflow website:\nFirst, Install SDKMAN\ncurl -s https://get.sdkman.io | bash\nSecond, open a new terminal, and install Java:\nsdk install java 17.0.10-tem\nFinally, confirm that Java in installed correctly:\njava -version",
    "crumbs": [
      "Setup your HPC account"
    ]
  },
  {
    "objectID": "02_setup.html#install-julia",
    "href": "02_setup.html#install-julia",
    "title": "Setting up your HPC account",
    "section": "Install Julia",
    "text": "Install Julia\nAt the time of writing, Julia 1.11 is causing various issues, so install Julia 1.10 using the “Linux and FreeBSD” instructions but using the URL for the Long-term support version 1.10.6.\nYou do not need root privileges, e.g., install in a folder at ~/bin/ and add to your path.",
    "crumbs": [
      "Setup your HPC account"
    ]
  },
  {
    "objectID": "02_setup.html#julia-depot",
    "href": "02_setup.html#julia-depot",
    "title": "Setting up your HPC account",
    "section": "Julia depot",
    "text": "Julia depot\nJulia has a package manager called Pkg. The Julia depot folder is a location where Pkg puts files it downloads and compiles. Each user should have their own. The path to the depot is controlled via the JULIA_DEPOT_PATH environment variable.\nIn a HPC setup, the JULIA_DEPOT_PATH should be accessible read/write by all nodes, and ideally be on fast storage.\nFor example, on Sockeye the first choice if you allocation has it would be to use burst storage, i.e. path of the form\nexport JULIA_DEPOT_PATH=/arc/burst/[allocation_code]/[username_in_alloc]/depot\nA second choice would be to use the scratch space\nexport JULIA_DEPOT_PATH=/scratch/[allocation_code]/[username_in_alloc]/depot",
    "crumbs": [
      "Setup your HPC account"
    ]
  },
  {
    "objectID": "02_setup.html#optional-useful-aliases",
    "href": "02_setup.html#optional-useful-aliases",
    "title": "Setting up your HPC account",
    "section": "Optional: useful aliases",
    "text": "Optional: useful aliases\nBash supports shortcuts called alias for commonly used commands. We show two use cases here.\nA very common patter in Julia is to activate the environment in the current directory and load Revise.jl. To do so, create a Julia script in your home directory called julia-start.jl and put that in it:\nprintln(\"Active project: $(Base.active_project())\")\nprintln(\"Loading Revise...\")\nusing Revise\nThen add the following to .bashrc:\nalias j='julia --banner=no --load /home/[your_alloc]/julia-start.jl --project=@. ' \nYou will need to install Revise.jl in the global environment:\njulia\n]\nactivate\nadd Revise \nSecond, most HPC has some ways to start an interactive allocation. Create an alias to be able to do it quicly. Here is an example for interactive CPU and GPU nodes respectively on Sockeye:\nalias interact='salloc --time=3:00:00 --mem=16G --nodes=1 --ntasks=2 --account=[your_alloc]'\nalias ginteract='salloc --account=[your_alloc-gpu] --partition=interactive_gpu --time=3:00:00 -N 1 -n 2 --mem=16G --gpus=1'",
    "crumbs": [
      "Setup your HPC account"
    ]
  },
  {
    "objectID": "02_setup.html#footnotes",
    "href": "02_setup.html#footnotes",
    "title": "Setting up your HPC account",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nWe emphasize “sometimes” here: for example, when nextflow calls bash, to make things reproducible, it does not automatically pass environment variables. They have to be set explicitly using input environment variables. More generally, any parent process is free to decide which environment variables to propagate to its child. Bash uses export to make this decision automatically when it starts a child. Other languages such as nextflow make different decisions.↩︎",
    "crumbs": [
      "Setup your HPC account"
    ]
  },
  {
    "objectID": "01_intro.html",
    "href": "01_intro.html",
    "title": "Intro",
    "section": "",
    "text": "Large scale numerical experiments are central to much of contemporary scientific and mathematical research. Performing these numerical experiments in a valid, reproducible and scalable fashion is not easy. Even a small typical project may need to run 1000s of executions, and 10k+ is not uncommon. It is crucial to have good tools to coordinate and organize these experiments.",
    "crumbs": [
      "Introduction"
    ]
  },
  {
    "objectID": "01_intro.html#context",
    "href": "01_intro.html#context",
    "title": "Intro",
    "section": "",
    "text": "Large scale numerical experiments are central to much of contemporary scientific and mathematical research. Performing these numerical experiments in a valid, reproducible and scalable fashion is not easy. Even a small typical project may need to run 1000s of executions, and 10k+ is not uncommon. It is crucial to have good tools to coordinate and organize these experiments.",
    "crumbs": [
      "Introduction"
    ]
  },
  {
    "objectID": "01_intro.html#nf-nest",
    "href": "01_intro.html#nf-nest",
    "title": "Intro",
    "section": "nf-nest",
    "text": "nf-nest\nThis webpage documents nf-nest, a collection of small but powerful utilities built on nextflow to help accomplish this.\nAspects taken into account:\n\nAutomating cross-product of input parameters in experiments.\nAutomating creation of submission scripts and ordering of jobs (taking care of moving across file system, dynamic memory requirements, etc).\nAutomating the gathering of results from many runs.\nCaching already ran jobs.\nRobustness to failure.\nReproducibility via apptainer and docker, supporting both x86 and apple silicon.\nSupport for GPU programming.",
    "crumbs": [
      "Introduction"
    ]
  },
  {
    "objectID": "01_intro.html#technology-stack",
    "href": "01_intro.html#technology-stack",
    "title": "Intro",
    "section": "Technology stack",
    "text": "Technology stack\nnf-nest uses the following open source projects:\n\nNextflow: can be thought of as an “operating system” for coordinating numerical experiments.\nJulia: a programming language to unlock full access to high performance computation on both CPUs and GPUs.\n\nWhile some features of nf-nest are Julia specific, other parts are language agnostic.",
    "crumbs": [
      "Introduction"
    ]
  },
  {
    "objectID": "01_intro.html#background",
    "href": "01_intro.html#background",
    "title": "Intro",
    "section": "Background",
    "text": "Background\n\nScientific workflow\nA scientific workflow is a directed acyclic graph where each node is a process and each edge between node \\(n\\) to \\(n'\\) denote that at least one output of process \\(n\\) is fed as an input to process \\(n'\\).\nHere is an example from a workflow covered later in this tutorial:\n\n\n\n\n\nflowchart TB\n    subgraph \" \"\n    v0[\"julia_env\"]\n    v1[\"toml\"]\n    v4[\"Channel.fromList\"]\n    v7[\"julia_env\"]\n    v8[\"toml\"]\n    v12[\"plot_script\"]\n    end\n    v2([instantiate_process])\n    v3([precompile])\n    v5([run_julia])\n    subgraph combine_workflow\n    v9([instantiate_process])\n    v10([precompile])\n    v11([combine_process])\n    end\n    v13([plot])\n    subgraph \" \"\n    v14[\"combined_csvs_folder\"]\n    v15[\" \"]\n    end\n    v6(( ))\n    v0 --&gt; v2\n    v1 --&gt; v2\n    v2 --&gt; v3\n    v3 --&gt; v5\n    v3 --&gt; v13\n    v4 --&gt; v5\n    v5 --&gt; v6\n    v7 --&gt; v9\n    v8 --&gt; v9\n    v9 --&gt; v10\n    v10 --&gt; v11\n    v6 --&gt; v11\n    v11 --&gt; v13\n    v12 --&gt; v13\n    v13 --&gt; v15\n    v13 --&gt; v14",
    "crumbs": [
      "Introduction"
    ]
  },
  {
    "objectID": "01_intro.html#more-information",
    "href": "01_intro.html#more-information",
    "title": "Intro",
    "section": "More information",
    "text": "More information\nBoth nextflow and Julia have excellent and extensive documentation.\n\nNexflow documentation\nJulia documentation",
    "crumbs": [
      "Introduction"
    ]
  },
  {
    "objectID": "06_cross_product.html",
    "href": "06_cross_product.html",
    "title": "Job cross products",
    "section": "",
    "text": "Suppose you are interested in running a piece of code with many different outputs, with each execution performed on a different compute node of a cluster.\nThis page shows a streamlined way to do so.",
    "crumbs": [
      "Job cross products"
    ]
  },
  {
    "objectID": "06_cross_product.html#overview",
    "href": "06_cross_product.html#overview",
    "title": "Job cross products",
    "section": "",
    "text": "Suppose you are interested in running a piece of code with many different outputs, with each execution performed on a different compute node of a cluster.\nThis page shows a streamlined way to do so.",
    "crumbs": [
      "Job cross products"
    ]
  },
  {
    "objectID": "06_cross_product.html#example",
    "href": "06_cross_product.html#example",
    "title": "Job cross products",
    "section": "Example",
    "text": "Example\nAs a toy example, suppose we want to compute all additions of the form a + b where a and b are integers from 1 to 3. In addition, we also want a * b. This means we will need \\(3 \\times 3 \\times 2\\) calculations.\nWe can characterize the inputs a the cross-product denoted \\(\\{1, 2, 3\\} \\times \\{1, 2, 3\\} \\times \\{+, *\\}\\).",
    "crumbs": [
      "Job cross products"
    ]
  },
  {
    "objectID": "06_cross_product.html#nextflow-script",
    "href": "06_cross_product.html#nextflow-script",
    "title": "Job cross products",
    "section": "Nextflow script",
    "text": "Nextflow script\nThe script below will perform the following operations.\n\n// we use utilities in the nf-nest submodule\n// in user scripts, path would be './nf-nest/cross.nf' \ninclude { crossProduct; filed; deliverables } from '../cross.nf'\ninclude { instantiate; precompile; activate } from '../pkg.nf'\n\ndef variables = [\n    first: 1..3,\n    second: 1..3,\n    operation: [\"+\", \"*\"]\n]\n\n// specifies the order of operations\nworkflow {\n    // look at all combinations of variables\n    configs = crossProduct(variables)\n    // run Julia on 18 nodes!\n    run_julia(configs)\n\n    // equivalent syntax:\n    // crossProduct(variables) | run_julia\n}\n\nprocess run_julia {\n    debug true // by default, standard out is not shown, use this to show it\n    \n    // information used when submitting job to queue\n    time 2.min\n    cpus 1 \n    memory 5.GB\n\n    input:\n        val config \n    \"\"\"\n    ${activate()}\n    # ^ this is just a shortcut for:\n    #!/usr/bin/env julia --threads=1\n\n    @show ${config.first} ${config.operation} ${config.second}\n    \"\"\"\n}\n\nFor more information:\n\nRead on the nextflow scripting language\nRead on nextflow’s process block\nconfigs in the above is an example of a nextflow Channel\nMore on nextflow’s workflow block",
    "crumbs": [
      "Job cross products"
    ]
  },
  {
    "objectID": "06_cross_product.html#running-the-script",
    "href": "06_cross_product.html#running-the-script",
    "title": "Job cross products",
    "section": "Running the script",
    "text": "Running the script\nRunning it with the -profile cluster option will:\n\nbuild a cross-product from variables\nfor each one, automatically create submission scripts\nrun these Julia processes and show the standard out.\n\nFrom the command line, running the script is done as follows:\n\ncd experiment_repo\n./nextflow run nf-nest/examples/many_jobs.nf -profile cluster\n\nN E X T F L O W  ~  version 24.10.0\nWARN: It appears you have never run this project before -- Option `-resume` is ignored\nLaunching `nf-nest/examples/many_jobs.nf` [sad_agnesi] DSL2 - revision: aa082b1978\n[4f/0252f2] Submitted process &gt; run_julia (9)\n[d1/7252a5] Submitted process &gt; run_julia (6)\n[77/2b01c0] Submitted process &gt; run_julia (11)\n[9e/04fbdc] Submitted process &gt; run_julia (5)\n[64/e04736] Submitted process &gt; run_julia (3)\n[f4/222d52] Submitted process &gt; run_julia (4)\n[39/4aad19] Submitted process &gt; run_julia (8)\n[f6/45fadc] Submitted process &gt; run_julia (15)\n[e0/7ecd79] Submitted process &gt; run_julia (2)\n[c8/e159cb] Submitted process &gt; run_julia (1)\n[83/20cd0c] Submitted process &gt; run_julia (12)\n[c5/395a82] Submitted process &gt; run_julia (7)\n[ab/373b0e] Submitted process &gt; run_julia (13)\n[77/403b66] Submitted process &gt; run_julia (14)\n[ba/9339d4] Submitted process &gt; run_julia (16)\n[a5/7edb62] Submitted process &gt; run_julia (10)\n[ec/974205] Submitted process &gt; run_julia (17)\n[8d/36196b] Submitted process &gt; run_julia (18)\n1 * 3 = 3\n2 + 3 = 5\n2 + 2 = 4\n1 + 3 = 4\n1 + 2 = 3\n1 * 2 = 2\n2 * 1 = 2\n3 + 2 = 5\n1 * 1 = 1\n1 + 1 = 2\n2 * 3 = 6\n2 + 1 = 3\n3 + 1 = 4\n3 * 1 = 3\n3 * 2 = 6\n2 * 2 = 4\n3 + 3 = 6\n3 * 3 = 9",
    "crumbs": [
      "Job cross products"
    ]
  },
  {
    "objectID": "03_create-exp-repo.html",
    "href": "03_create-exp-repo.html",
    "title": "Creating an experiment repo",
    "section": "",
    "text": "We use the term “experiment repo” for a git repository that contains the plumbing required for a numerical experiment.\nIt consists in a git repository with:\n\nthe nextflow executable and its configuration, nextflow.config;\na git submodule, nf-nest containing useful tools;\nyour .nf files and other supporting files.\n\nThis pages explains how to setup an experiment repo.",
    "crumbs": [
      "Create an experiment repo"
    ]
  },
  {
    "objectID": "03_create-exp-repo.html#overview",
    "href": "03_create-exp-repo.html#overview",
    "title": "Creating an experiment repo",
    "section": "",
    "text": "We use the term “experiment repo” for a git repository that contains the plumbing required for a numerical experiment.\nIt consists in a git repository with:\n\nthe nextflow executable and its configuration, nextflow.config;\na git submodule, nf-nest containing useful tools;\nyour .nf files and other supporting files.\n\nThis pages explains how to setup an experiment repo.",
    "crumbs": [
      "Create an experiment repo"
    ]
  },
  {
    "objectID": "03_create-exp-repo.html#location",
    "href": "03_create-exp-repo.html#location",
    "title": "Creating an experiment repo",
    "section": "Location",
    "text": "Location\nIn an HPC context, the experiment repo should be in a read/write location accessible to all nodes.\nFor example, on Sockeye the first choice if you allocation has it would be to use burst storage, i.e. cd to a path of the form\nexport JULIA_DEPOT_PATH=/arc/burst/[allocation_code]/[username_in_alloc]/\nA second choice would be to use the scratch space, i.e. cd to a path of the form\nexport JULIA_DEPOT_PATH=/scratch/[allocation_code]/[username_in_alloc]/",
    "crumbs": [
      "Create an experiment repo"
    ]
  },
  {
    "objectID": "03_create-exp-repo.html#sec-instructions",
    "href": "03_create-exp-repo.html#sec-instructions",
    "title": "Creating an experiment repo",
    "section": "Instructions",
    "text": "Instructions\nFor quick setup, run the following commands:\n\n# create a directory and cd into it\nmkdir experiment_repo && cd $_\n\ngit init\n\n# setup nextflow\ncurl -s https://get.nextflow.io | bash\n\n# add nf-nest utilities\ngit submodule add https://github.com/UBC-Stat-ML/nf-nest.git\n\n# copy template for nextflow configurations\ncp nf-nest/nextflow.config .",
    "crumbs": [
      "Create an experiment repo"
    ]
  },
  {
    "objectID": "05_pkg.html",
    "href": "05_pkg.html",
    "title": "Managing Julia packages on HPC",
    "section": "",
    "text": "Installing a package in Julia includes two steps (1) downloading (2) pre-compiling. In a laptop, both are done in one shot using\n]\nactivate experiment_repo/julia_env\nadd NameOfPackage\nIn an HPC setup, step (2) requires computational effort hence is best done in compute node. However in some HPC setups such as Sockeye, compute nodes do not have internet access, so the process needs to be split. We cover here some utilities that facilitate this.",
    "crumbs": [
      "Add Julia packages on HPC"
    ]
  },
  {
    "objectID": "05_pkg.html#overview",
    "href": "05_pkg.html#overview",
    "title": "Managing Julia packages on HPC",
    "section": "",
    "text": "Installing a package in Julia includes two steps (1) downloading (2) pre-compiling. In a laptop, both are done in one shot using\n]\nactivate experiment_repo/julia_env\nadd NameOfPackage\nIn an HPC setup, step (2) requires computational effort hence is best done in compute node. However in some HPC setups such as Sockeye, compute nodes do not have internet access, so the process needs to be split. We cover here some utilities that facilitate this.",
    "crumbs": [
      "Add Julia packages on HPC"
    ]
  },
  {
    "objectID": "05_pkg.html#julia-environment",
    "href": "05_pkg.html#julia-environment",
    "title": "Managing Julia packages on HPC",
    "section": "Julia environment",
    "text": "Julia environment\nA Julia environment is a specification of all package dependencies and their versions.\nBy convention, we will store it in a directory called experiment_repo/julia_env.",
    "crumbs": [
      "Add Julia packages on HPC"
    ]
  },
  {
    "objectID": "05_pkg.html#adding-a-package",
    "href": "05_pkg.html#adding-a-package",
    "title": "Managing Julia packages on HPC",
    "section": "Adding a package",
    "text": "Adding a package\nThere are two syntaxes in Julia to install packages: the interactive Julia package manager or using programmatic Pkg syntax. We cover both below.\nIn both syntaxes, we first need to tell Julia which environment to use. This is called “activating” an environment.\n\nInteractive Julia package manager\nThe most common method is to use the interactive Julia package manager. To start it, type ] followed by enter.\nActivating is done with the activate keyword.\nYou can then add a package using the add command. The argument of add can be either a registered Julia package, for example we show here how to add the Pigeons package for MCMC sampling:\nENV[\"JULIA_PKG_PRECOMPILE_AUTO\"]=0 # Hold off precompile since we are in login node\n]\nactivate experiment_repo/julia_env\nadd Pigeons\nAlternatively, the package can be a git repository, optionally with a specific commit/tag:\nadd Example@0.5\nadd Example#master\nadd Example#c37b675\nadd https://github.com/JuliaLang/Example.jl#master\nadd git@github.com:JuliaLang/Example.jl.git\nadd \"git@github.com:JuliaLang/Example.jl.git\"#master\nadd https://github.com/Company/MonoRepo:juliapkgs/Package.jl\nTo exit the interactive Julia package manager, type control-C.\n\n\nProgrammatic interface\nAlternatively, a programmatic interface is also available for scripting:\n\nENV[\"JULIA_PKG_PRECOMPILE_AUTO\"]=0 # Hold off precompile since we are in login node\nusing Pkg \nPkg.activate(\"experiment_repo/julia_env\")\nPkg.add(\"Pigeons\")",
    "crumbs": [
      "Add Julia packages on HPC"
    ]
  },
  {
    "objectID": "05_pkg.html#precompilation-on-hpc",
    "href": "05_pkg.html#precompilation-on-hpc",
    "title": "Managing Julia packages on HPC",
    "section": "Precompilation on HPC",
    "text": "Precompilation on HPC\nOnce we have downloaded the packages in the login node, we now turn to the task of performing pre-compilation.\n\ncd experiment_repo \n./nextflow run nf-nest/pkg.nf -profile cluster\n\nN E X T F L O W  ~  version 24.10.0\nLaunching `nf-nest/pkg.nf` [reverent_curran] DSL2 - revision: fc0374e695\n[43/8256a8] Submitted process &gt; instantiate_process\n[02/7c263d] Submitted process &gt; precompile\n\n\nOptionally, you can append an argument to specify the number of threads to request and use during pre-compilation: e.g. add --nPrecompileThreads 20 to request 20 threads instead of the default of 10.",
    "crumbs": [
      "Add Julia packages on HPC"
    ]
  },
  {
    "objectID": "05_pkg.html#testing-your-julia-environment-interactively",
    "href": "05_pkg.html#testing-your-julia-environment-interactively",
    "title": "Managing Julia packages on HPC",
    "section": "Testing your Julia environment interactively",
    "text": "Testing your Julia environment interactively\nIn the code above, we have added the package Pigeons as an example.\nTo interactively test an installed package, simply activate the environment from a Julia session:\n\nusing Pkg\nPkg.activate(\"experiment_repo/julia_env\")\n\nusing Pigeons\npigeons(target = toy_mvn_target(1000))",
    "crumbs": [
      "Add Julia packages on HPC"
    ]
  },
  {
    "objectID": "05_pkg.html#more-information",
    "href": "05_pkg.html#more-information",
    "title": "Managing Julia packages on HPC",
    "section": "More information",
    "text": "More information\nSee Pkg.jl documentation.",
    "crumbs": [
      "Add Julia packages on HPC"
    ]
  },
  {
    "objectID": "08_containers.html",
    "href": "08_containers.html",
    "title": "Containers",
    "section": "",
    "text": "Containers such as Docker and apptainer address two issues:\n\nmaking pipeline reproducible,\nwe do not have root access in HPC.",
    "crumbs": [
      "Containers"
    ]
  },
  {
    "objectID": "08_containers.html#overview",
    "href": "08_containers.html#overview",
    "title": "Containers",
    "section": "",
    "text": "Containers such as Docker and apptainer address two issues:\n\nmaking pipeline reproducible,\nwe do not have root access in HPC.",
    "crumbs": [
      "Containers"
    ]
  },
  {
    "objectID": "08_containers.html#using-an-existing-container",
    "href": "08_containers.html#using-an-existing-container",
    "title": "Containers",
    "section": "Using an existing container",
    "text": "Using an existing container\nIn the file nextflow.config provided in nf-nest we provide an example of container documentation:\n\nhead -n 28 experiment_repo/nextflow.config\n\nprofiles {\n    standard {  \n        docker.enabled = true\n        process {\n            withLabel:containerized {\n                container = 'alexandrebouchardcote/default:0.1.6'\n            }\n        }\n    }\n    cluster {\n        apptainer.enabled = true\n        process {\n            scratch = true\n            executor = 'slurm'\n            cpus = 1\n            memory = 4.GB\n            time = '2h'\n            clusterOptions = \"--nodes=1 --account $ALLOCATION_CODE\"\n            withLabel:containerized {\n                container = 'alexandrebouchardcote/default:0.1.6'\n                module = 'apptainer'\n            }\n            withLabel:gpu {\n                clusterOptions = \"--nodes=1 --account ${ALLOCATION_CODE}-gpu --gpus 1\"\n            }\n        }\n    }\n}\n\n\nThere are two profiles, the default one using Docker, and the cluster one, using apptainer. We define a label for this container, which we call here containerized.\nTo instruct one of the process in the workflow to use that container, add the directive label 'containerized'.\nHere is an example of a process to compile and run a Stan program, where Stan is part of the above container:\n\nprocess compile_stan {\n    label 'containerized' \n\n    input:\n        path stan_file\n    output:\n        path \"${stan_file.baseName}\"\n        \n    \"\"\"\n    # name of stan file without extension\n    base_name=`basename $stan_file .stan`\n\n    # need to run Stan's make file from the CMDSTAN dir\n    CUR=`pwd`\n    cd \\$CMDSTAN\n    make \\$CUR/\\$base_name\n    \"\"\"\n}\n\nprocess run_stan {\n    label 'containerized' \n\n    input:\n        path stan_exec \n        path data\n\n    \"\"\"\n    ./$stan_exec sample \\\n        data file=$data \\\n        output file=samples.csv \n\n    # Compute ESS from Stan's stansummary utility\n    \\$CMDSTAN/bin/stansummary samples.csv --csv_filename ess.csv\n    \"\"\"\n}\n\nHere is an example workflow using these containerized processes:\n\ninclude { compile_stan; run_stan; } from \"./stan.nf\"\n\ndef stanModel = file(\"https://raw.githubusercontent.com/Julia-Tempering/Pigeons.jl/refs/heads/main/examples/stan/bernoulli.stan\")\ndef data = file(\"https://raw.githubusercontent.com/Julia-Tempering/Pigeons.jl/refs/heads/main/examples/stan/bernoulli.data.json\")\n\nworkflow {\n    compiled = compile_stan(stanModel)\n    run_stan(compiled, data)\n}\n\nTo run it:\n\ncd experiment_repo\n./nextflow run nf-nest/examples/stan_example.nf -profile cluster\n\nN E X T F L O W  ~  version 24.10.0\nLaunching `nf-nest/examples/stan_example.nf` [drunk_gautier] DSL2 - revision: 8cef9f29d6\nWARN: Apptainer cache directory has not been defined -- Remote image will be stored in the path: /arc/burst/st-alexbou-1/abc/nf-nest-doc/experiment_repo/work/singularity -- Use the environment variable NXF_APPTAINER_CACHEDIR to specify a different location\nPulling Apptainer image docker://alexandrebouchardcote/default:0.1.6 [cache /arc/burst/st-alexbou-1/abc/nf-nest-doc/experiment_repo/work/singularity/alexandrebouchardcote-default-0.1.6.img]\n[ed/1e5ab8] Submitted process &gt; compile_stan\n[3e/f8706a] Submitted process &gt; run_stan",
    "crumbs": [
      "Containers"
    ]
  },
  {
    "objectID": "08_containers.html#creating-containers",
    "href": "08_containers.html#creating-containers",
    "title": "Containers",
    "section": "Creating containers",
    "text": "Creating containers\nThere are many reference online for creating containers in general, but much less on creating cross-platform containers working on both x86 and Apple Silicon.\nWe have created some script to help doing this, see code and instructions at this page.",
    "crumbs": [
      "Containers"
    ]
  }
]